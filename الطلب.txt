في SQL Editor بتنفيذ:
-- جداول public
select table_name, table_type
from information_schema.tables
where table_schema = 'public'
order by table_name;

-- جميع الدوال في public
select proname as function_name,
       pg_get_functiondef(p.oid) as definition
from pg_proc p
join pg_namespace n on n.oid = p.pronamespace
where n.nspname = 'public'
order by proname;

-- سياسات RLS
select schemaname, tablename, policyname, permissive, roles, cmd, qual, with_check
from pg_policies
where schemaname = 'public'
order by tablename, policyname;

-- صلاحيات الجداول
select table_schema, table_name, privilege_type, grantee
from information_schema.table_privileges
where table_schema = 'public'
order by table_name, grantee;

-- المايغريشنات كما هي مخزّنة (سيُظهر ما هي الأعمدة المتاحة لديك)
select *
from supabase_migrations.schema_migrations
order by 1 desc;



وكانت النيجة:
[
  {
    "version": "20251123031000",
    "statements": [
      "-- 20251123031000_membership_functions_rls_off.sql\n-- Ensures membership helper RPCs bypass account_users RLS entirely to avoid\n-- recursion/timeouts when validating accounts or listing employees.\n\ncreate or replace function public.my_account_id()\nreturns uuid\nlanguage plpgsql\nsecurity definer\nset search_path = public, auth\nas $$\ndeclare\n  result uuid;\nbegin\n  execute 'set local row_security = off';\n\n  select account_id\n    into result\n    from public.account_users\n   where user_uid = auth.uid()\n     and coalesce(disabled, false) = false\n   order by created_at desc\n   limit 1;\n\n  return result;\nend;\n$$",
      "revoke all on function public.my_account_id() from public",
      "grant execute on function public.my_account_id() to authenticated",
      "create or replace function public.my_accounts()\nreturns setof uuid\nlanguage plpgsql\nsecurity definer\nset search_path = public, auth\nas $$\nbegin\n  execute 'set local row_security = off';\n\n  return query\n  select account_id\n    from public.account_users\n   where user_uid = auth.uid()\n     and coalesce(disabled, false) = false\n   order by created_at desc;\nend;\n$$",
      "revoke all on function public.my_accounts() from public",
      "grant execute on function public.my_accounts() to authenticated",
      "create or replace function public.my_profile()\nreturns table (\n  user_uid   uuid,\n  email      text,\n  account_id uuid,\n  role       text,\n  disabled   boolean\n)\nlanguage plpgsql\nsecurity definer\nstable\nset search_path = public, auth\nas $$\nbegin\n  execute 'set local row_security = off';\n\n  return query\n  with membership as (\n    select\n      au.account_id,\n      au.role::text,\n      coalesce(au.disabled, false) as disabled\n    from public.account_users au\n    where au.user_uid = auth.uid()\n    order by au.created_at desc\n    limit 1\n  )\n  select\n    u.id as user_uid,\n    u.email,\n    membership.account_id,\n    coalesce(membership.role, 'employee') as role,\n    coalesce(membership.disabled, false) as disabled\n  from auth.users u\n  left join membership on true\n  where u.id = auth.uid()\n  limit 1;\nend;\n$$",
      "revoke all on function public.my_profile() from public",
      "grant execute on function public.my_profile() to authenticated",
      "create or replace function public.list_employees_with_email(p_account uuid)\nreturns table(\n  user_uid uuid,\n  email text,\n  role text,\n  disabled boolean,\n  created_at timestamptz,\n  employee_id uuid,\n  doctor_id uuid\n) as $$\ndeclare\n  claims jsonb := coalesce(current_setting('request.jwt.claims', true)::jsonb, '{}'::jsonb);\n  caller_uid uuid := nullif(claims->>'sub','')::uuid;\n  caller_email text := lower(coalesce(claims->>'email',''));\n  super_admin_email text := 'admin@elmam.com';\n  can_manage boolean;\nbegin\n  execute 'set local row_security = off';\n\n  select exists (\n    select 1\n    from public.account_users\n    where account_id = p_account\n      and user_uid = caller_uid\n      and role in ('owner','admin')\n      and coalesce(disabled,false) = false\n  ) into can_manage;\n\n  if not (can_manage or caller_email = lower(super_admin_email)) then\n    raise exception 'forbidden' using errcode = '42501';\n  end if;\n\n  return query\n  select\n    au.user_uid,\n    coalesce(u.email, au.email),\n    au.role,\n    coalesce(au.disabled,false) as disabled,\n    au.created_at,\n    e.id as employee_id,\n    d.id as doctor_id\n  from public.account_users au\n  left join auth.users u on u.id = au.user_uid\n  left join public.employees e on e.account_id = au.account_id and e.user_uid = au.user_uid\n  left join public.doctors d on d.account_id = au.account_id and d.user_uid = au.user_uid\n  where au.account_id = p_account\n  order by au.created_at desc;\nend;\n$$ language plpgsql\nsecurity definer\nset search_path = public, auth",
      "revoke all on function public.list_employees_with_email(uuid) from public",
      "grant execute on function public.list_employees_with_email(uuid) to authenticated"
    ],
    "name": "membership_functions_rls_off"
  },
  {
    "version": "20251123020000",
    "statements": [
      "-- 20251123020000_fn_is_account_member_rows_off.sql\n-- Ensures fn_is_account_member bypasses account_users RLS entirely to prevent\n-- stack-depth recursion when policies call the helper.\n\nCREATE OR REPLACE FUNCTION public.fn_is_account_member(p_account uuid)\nRETURNS boolean\nLANGUAGE plpgsql\nSTABLE\nSECURITY DEFINER\nSET search_path = public\nAS $$\nDECLARE\n  result boolean := false;\n  elevated boolean := false;\nBEGIN\n  IF p_account IS NULL THEN\n    RETURN false;\n  END IF;\n\n  BEGIN\n    EXECUTE 'set local role postgres';\n    EXECUTE 'set local row_security = off';\n    elevated := true;\n\n    SELECT EXISTS (\n      SELECT 1\n        FROM public.account_users au\n       WHERE au.account_id = p_account\n         AND au.user_uid::text = auth.uid()::text\n         AND COALESCE(au.disabled, false) = false\n    )\n    INTO result;\n  EXCEPTION\n    WHEN OTHERS THEN\n      IF elevated THEN\n        BEGIN\n          EXECUTE 'reset role';\n        EXCEPTION\n          WHEN OTHERS THEN NULL;\n        END;\n        elevated := false;\n      END IF;\n      RAISE;\n  END;\n\n  IF elevated THEN\n    BEGIN\n      EXECUTE 'reset role';\n    EXCEPTION\n      WHEN OTHERS THEN NULL;\n    END;\n  END IF;\n\n  RETURN COALESCE(result, false);\nEND;\n$$",
      "REVOKE ALL ON FUNCTION public.fn_is_account_member(uuid) FROM PUBLIC",
      "GRANT EXECUTE ON FUNCTION public.fn_is_account_member(uuid) TO authenticated"
    ],
    "name": "fn_is_account_member_rows_off"
  },
  {
    "version": "20251123010000",
    "statements": [
      "-- 20251123010000_fix_admin_provisioning_and_membership.sql\n-- Resolves recursive account membership checks (stack depth failures) and\n-- teaches the admin RPCs to create/link auth users directly so that the\n-- Flutter super-admin panel can provision owners/employees reliably.\n\nBEGIN",
      "-- Helper: resolve or create an auth user with the supplied credentials/role.\nCREATE OR REPLACE FUNCTION public.admin_resolve_or_create_auth_user(\n  p_email text,\n  p_password text DEFAULT NULL,\n  p_role text DEFAULT 'employee'\n) RETURNS uuid\nLANGUAGE plpgsql\nSECURITY DEFINER\nSET search_path = public, auth\nAS $$\nDECLARE\n  normalized_email text := lower(coalesce(trim(p_email), ''));\n  normalized_role text := coalesce(nullif(trim(p_role), ''), 'employee');\n  normalized_password text := nullif(coalesce(trim(p_password), ''), '');\n  target_uid uuid;\n  escalated boolean := false;\nBEGIN\n  IF normalized_email = '' THEN\n    RAISE EXCEPTION 'email is required';\n  END IF;\n\n  SELECT id\n    INTO target_uid\n    FROM auth.users\n   WHERE lower(email) = normalized_email\n   ORDER BY created_at DESC\n   LIMIT 1;\n\n  IF target_uid IS NULL THEN\n    IF normalized_password IS NULL THEN\n      RAISE EXCEPTION 'password is required to create user %', normalized_email\n        USING ERRCODE = '22023';\n    END IF;\n\n    BEGIN\n      EXECUTE 'set local role supabase_auth_admin';\n      escalated := true;\n\n      SELECT id\n        INTO target_uid\n        FROM auth.create_user(\n          jsonb_build_object(\n            'email', normalized_email,\n            'password', normalized_password,\n            'email_confirm', true,\n            'app_metadata', jsonb_build_object(\n              'role', normalized_role,\n              'provider', 'email',\n              'providers', jsonb_build_array('email')\n            ),\n            'user_metadata', jsonb_build_object(\n              'role', normalized_role,\n              'email_verified', true\n            )\n          )\n        );\n    EXCEPTION\n      WHEN OTHERS THEN\n        IF escalated THEN\n          BEGIN\n            EXECUTE 'reset role';\n          EXCEPTION\n            WHEN OTHERS THEN NULL;\n          END;\n          escalated := false;\n        END IF;\n        RAISE;\n    END;\n\n    IF escalated THEN\n      BEGIN\n        EXECUTE 'reset role';\n      EXCEPTION\n        WHEN OTHERS THEN NULL;\n      END;\n      escalated := false;\n    END IF;\n  END IF;\n\n  UPDATE auth.users\n     SET email_confirmed_at = COALESCE(email_confirmed_at, now()),\n         raw_app_meta_data = COALESCE(raw_app_meta_data, '{}'::jsonb) || jsonb_build_object(\n           'role', normalized_role,\n           'provider', 'email',\n           'providers', jsonb_build_array('email')\n         ),\n         raw_user_meta_data = COALESCE(raw_user_meta_data, '{}'::jsonb) || jsonb_build_object(\n           'role', normalized_role,\n           'email_verified', true\n         )\n   WHERE id = target_uid;\n\n  RETURN target_uid;\nEND;\n$$",
      "REVOKE ALL ON FUNCTION public.admin_resolve_or_create_auth_user(text, text, text) FROM PUBLIC",
      "GRANT EXECUTE ON FUNCTION public.admin_resolve_or_create_auth_user(text, text, text) TO authenticated",
      "GRANT EXECUTE ON FUNCTION public.admin_resolve_or_create_auth_user(text, text, text) TO service_role",
      "-- Fix fn_is_account_member recursion by temporarily elevating the role.\nCREATE OR REPLACE FUNCTION public.fn_is_account_member(p_account uuid)\nRETURNS boolean\nLANGUAGE plpgsql\nSTABLE\nSECURITY DEFINER\nSET search_path = public\nAS $$\nDECLARE\n  result boolean := false;\n  escalated boolean := false;\nBEGIN\n  IF p_account IS NULL THEN\n    RETURN false;\n  END IF;\n\n  BEGIN\n    EXECUTE 'set local role postgres';\n    escalated := true;\n\n    SELECT EXISTS (\n      SELECT 1\n        FROM public.account_users au\n       WHERE au.account_id = p_account\n         AND au.user_uid::text = auth.uid()::text\n         AND COALESCE(au.disabled, false) = false\n    )\n    INTO result;\n  EXCEPTION\n    WHEN OTHERS THEN\n      IF escalated THEN\n        BEGIN\n          EXECUTE 'reset role';\n        EXCEPTION\n          WHEN OTHERS THEN NULL;\n        END;\n        escalated := false;\n      END IF;\n      RAISE;\n  END;\n\n  IF escalated THEN\n    BEGIN\n      EXECUTE 'reset role';\n    EXCEPTION\n      WHEN OTHERS THEN NULL;\n    END;\n  END IF;\n\n  RETURN COALESCE(result, false);\nEND;\n$$",
      "REVOKE ALL ON FUNCTION public.fn_is_account_member(uuid) FROM PUBLIC",
      "GRANT EXECUTE ON FUNCTION public.fn_is_account_member(uuid) TO authenticated",
      "-- Admin RPC: create/attach clinic owner (auth user auto-created when needed).\nCREATE OR REPLACE FUNCTION public.admin_create_owner_full(\n  p_clinic_name text,\n  p_owner_email text,\n  p_owner_password text DEFAULT NULL\n)\nRETURNS jsonb\nLANGUAGE plpgsql\nSECURITY DEFINER\nSET search_path = public, auth\nAS $$\nDECLARE\n  claims jsonb := coalesce(current_setting('request.jwt.claims', true)::jsonb, '{}'::jsonb);\n  caller_email text := lower(coalesce(claims->>'email', ''));\n  normalized_clinic text := coalesce(nullif(trim(p_clinic_name), ''), '');\n  normalized_email text := lower(coalesce(trim(p_owner_email), ''));\n  normalized_role text := 'owner';\n  normalized_password text := nullif(coalesce(trim(p_owner_password), ''), '');\n  owner_uid uuid;\n  acc_id uuid;\nBEGIN\n  IF normalized_clinic = '' OR normalized_email = '' THEN\n    RETURN jsonb_build_object('ok', false, 'error', 'clinic_name and owner_email are required');\n  END IF;\n\n  IF NOT (fn_is_super_admin() = true OR caller_email = 'admin@elmam.com') THEN\n    RAISE EXCEPTION 'forbidden' USING ERRCODE = '42501';\n  END IF;\n\n  owner_uid := public.admin_resolve_or_create_auth_user(\n    normalized_email,\n    normalized_password,\n    normalized_role\n  );\n\n  INSERT INTO public.accounts(name, frozen)\n  VALUES (normalized_clinic, false)\n  RETURNING id INTO acc_id;\n\n  PERFORM public.admin_attach_employee(acc_id, owner_uid, normalized_role);\n\n  UPDATE public.account_users\n     SET email = normalized_email,\n         role = normalized_role,\n         disabled = false,\n         updated_at = now()\n   WHERE account_id = acc_id\n     AND user_uid = owner_uid;\n\n  UPDATE public.profiles\n     SET account_id = acc_id,\n         role = normalized_role,\n         email = normalized_email,\n         disabled = false,\n         updated_at = now()\n   WHERE id = owner_uid;\n\n  UPDATE auth.users\n     SET raw_app_meta_data = COALESCE(raw_app_meta_data, '{}'::jsonb) || jsonb_build_object(\n           'role', normalized_role,\n           'account_id', acc_id::text\n         ),\n         raw_user_meta_data = COALESCE(raw_user_meta_data, '{}'::jsonb) || jsonb_build_object(\n           'role', normalized_role,\n           'account_id', acc_id::text,\n           'email_verified', true\n         )\n   WHERE id = owner_uid;\n\n  RETURN jsonb_build_object(\n    'ok', true,\n    'account_id', acc_id::text,\n    'owner_uid', owner_uid::text,\n    'user_uid', owner_uid::text,\n    'role', normalized_role\n  );\nEND;\n$$",
      "REVOKE ALL ON FUNCTION public.admin_create_owner_full(text, text, text) FROM PUBLIC",
      "GRANT EXECUTE ON FUNCTION public.admin_create_owner_full(text, text, text) TO authenticated",
      "GRANT EXECUTE ON FUNCTION public.admin_create_owner_full(text, text, text) TO service_role",
      "-- Keep admin_bootstrap_clinic_for_email in sync with the new helper.\nCREATE OR REPLACE FUNCTION public.admin_bootstrap_clinic_for_email(\n  clinic_name text,\n  owner_email text,\n  owner_role text DEFAULT 'owner'\n)\nRETURNS uuid\nLANGUAGE plpgsql\nSECURITY DEFINER\nSET search_path = public, auth\nAS $$\nDECLARE\n  claims jsonb := coalesce(current_setting('request.jwt.claims', true)::jsonb, '{}'::jsonb);\n  caller_email text := lower(coalesce(claims->>'email', ''));\n  super_admin_email text := 'admin@elmam.com';\n  normalized_clinic text := coalesce(nullif(trim(clinic_name), ''), '');\n  normalized_email text := lower(coalesce(trim(owner_email), ''));\n  normalized_role text := coalesce(nullif(trim(owner_role), ''), 'owner');\n  clinic_id uuid;\n  owner_uid uuid;\nBEGIN\n  IF normalized_clinic = '' THEN\n    RAISE EXCEPTION 'clinic_name is required';\n  END IF;\n\n  IF normalized_email = '' THEN\n    RAISE EXCEPTION 'owner_email is required';\n  END IF;\n\n  IF NOT (fn_is_super_admin() = true OR caller_email = super_admin_email) THEN\n    RAISE EXCEPTION 'forbidden' USING ERRCODE = '42501';\n  END IF;\n\n  owner_uid := public.admin_resolve_or_create_auth_user(\n    normalized_email,\n    NULL,\n    normalized_role\n  );\n\n  INSERT INTO public.accounts(name, frozen)\n  VALUES (normalized_clinic, false)\n  RETURNING id INTO clinic_id;\n\n  PERFORM public.admin_attach_employee(clinic_id, owner_uid, normalized_role);\n\n  UPDATE public.account_users\n     SET email = normalized_email,\n         role = normalized_role,\n         disabled = false,\n         updated_at = now()\n   WHERE account_id = clinic_id\n     AND user_uid = owner_uid;\n\n  UPDATE public.profiles\n     SET account_id = clinic_id,\n         role = normalized_role,\n         email = normalized_email,\n         disabled = false,\n         updated_at = now()\n   WHERE id = owner_uid;\n\n  UPDATE auth.users\n     SET raw_app_meta_data = COALESCE(raw_app_meta_data, '{}'::jsonb) || jsonb_build_object(\n           'role', normalized_role,\n           'account_id', clinic_id::text\n         ),\n         raw_user_meta_data = COALESCE(raw_user_meta_data, '{}'::jsonb) || jsonb_build_object(\n           'role', normalized_role,\n           'account_id', clinic_id::text,\n           'email_verified', true\n         )\n   WHERE id = owner_uid;\n\n  RETURN clinic_id;\nEND;\n$$",
      "REVOKE ALL ON FUNCTION public.admin_bootstrap_clinic_for_email(text, text, text) FROM PUBLIC",
      "GRANT EXECUTE ON FUNCTION public.admin_bootstrap_clinic_for_email(text, text, text) TO authenticated",
      "CREATE OR REPLACE FUNCTION public.admin_bootstrap_clinic_for_email(\n  clinic_name text,\n  owner_email text\n)\nRETURNS uuid\nLANGUAGE plpgsql\nSECURITY DEFINER\nSET search_path = public, auth\nAS $$\nBEGIN\n  RETURN public.admin_bootstrap_clinic_for_email(clinic_name, owner_email, 'owner');\nEND;\n$$",
      "REVOKE ALL ON FUNCTION public.admin_bootstrap_clinic_for_email(text, text) FROM PUBLIC",
      "GRANT EXECUTE ON FUNCTION public.admin_bootstrap_clinic_for_email(text, text) TO authenticated",
      "-- Admin RPC: create/attach employee (auth user auto-created when needed).\nCREATE OR REPLACE FUNCTION public.admin_create_employee_full(\n  p_account uuid,\n  p_email text,\n  p_password text DEFAULT NULL\n)\nRETURNS jsonb\nLANGUAGE plpgsql\nSECURITY DEFINER\nSET search_path = public, auth\nAS $$\nDECLARE\n  claims jsonb := coalesce(current_setting('request.jwt.claims', true)::jsonb, '{}'::jsonb);\n  caller_email text := lower(coalesce(claims->>'email', ''));\n  normalized_email text := lower(coalesce(trim(p_email), ''));\n  normalized_role text := 'employee';\n  normalized_password text := nullif(coalesce(trim(p_password), ''), '');\n  emp_uid uuid;\n  account_exists boolean;\nBEGIN\n  IF NOT (fn_is_super_admin() = true OR caller_email = 'admin@elmam.com') THEN\n    RAISE EXCEPTION 'forbidden' USING ERRCODE = '42501';\n  END IF;\n\n  IF p_account IS NULL THEN\n    RAISE EXCEPTION 'account_id is required';\n  END IF;\n\n  IF normalized_email = '' THEN\n    RAISE EXCEPTION 'email is required';\n  END IF;\n\n  SELECT EXISTS (\n           SELECT 1 FROM public.accounts a WHERE a.id = p_account\n         )\n    INTO account_exists;\n\n  IF NOT COALESCE(account_exists, false) THEN\n    RAISE EXCEPTION 'account % not found', p_account;\n  END IF;\n\n  emp_uid := public.admin_resolve_or_create_auth_user(\n    normalized_email,\n    normalized_password,\n    normalized_role\n  );\n\n  PERFORM public.admin_attach_employee(p_account, emp_uid, normalized_role);\n\n  UPDATE public.account_users\n     SET email = normalized_email,\n         role = normalized_role,\n         disabled = false,\n         updated_at = now()\n   WHERE account_id = p_account\n     AND user_uid = emp_uid;\n\n  UPDATE public.profiles\n     SET account_id = p_account,\n         role = normalized_role,\n         email = normalized_email,\n         disabled = false,\n         updated_at = now()\n   WHERE id = emp_uid;\n\n  UPDATE auth.users\n     SET raw_app_meta_data = COALESCE(raw_app_meta_data, '{}'::jsonb) || jsonb_build_object(\n           'role', normalized_role,\n           'account_id', p_account::text\n         ),\n         raw_user_meta_data = COALESCE(raw_user_meta_data, '{}'::jsonb) || jsonb_build_object(\n           'role', normalized_role,\n           'account_id', p_account::text,\n           'email_verified', true\n         )\n   WHERE id = emp_uid;\n\n  RETURN jsonb_build_object(\n    'ok', true,\n    'account_id', p_account::text,\n    'user_uid', emp_uid::text,\n    'role', normalized_role\n  );\nEND;\n$$",
      "REVOKE ALL ON FUNCTION public.admin_create_employee_full(uuid, text, text) FROM PUBLIC",
      "GRANT EXECUTE ON FUNCTION public.admin_create_employee_full(uuid, text, text) TO authenticated",
      "GRANT EXECUTE ON FUNCTION public.admin_create_employee_full(uuid, text, text) TO service_role",
      "COMMIT"
    ],
    "name": "fix_admin_provisioning_and_membership"
  },
  {
    "version": "20251122093000",
    "statements": [
      "-- 20251122093000_fix_admin_bootstrap_loop.sql\n-- Fixes the accidental recursion on admin_bootstrap_clinic_for_email by\n-- restoring the original 3-arg implementation plus the thin 2-arg wrapper.\n\ncreate or replace function public.admin_bootstrap_clinic_for_email(\n  clinic_name text,\n  owner_email text,\n  owner_role text default 'owner'\n)\nreturns uuid\nlanguage plpgsql\nsecurity definer\nset search_path = public, auth\nas $$\ndeclare\n  claims jsonb := coalesce(current_setting('request.jwt.claims', true)::jsonb, '{}'::jsonb);\n  caller_email text := lower(coalesce(claims->>'email', ''));\n  super_admin_email text := 'admin@elmam.com';\n  normalized_email text := lower(coalesce(trim(owner_email), ''));\n  normalized_role text := coalesce(nullif(trim(owner_role), ''), 'owner');\n  owner_uid uuid;\n  acc_id uuid;\nbegin\n  if coalesce(trim(clinic_name), '') = '' then\n    raise exception 'clinic_name is required';\n  end if;\n\n  if normalized_email = '' then\n    raise exception 'owner_email is required';\n  end if;\n\n  if not (fn_is_super_admin() = true or caller_email = super_admin_email) then\n    raise exception 'forbidden' using errcode = '42501';\n  end if;\n\n  select id\n    into owner_uid\n  from auth.users\n  where lower(email) = normalized_email\n  order by created_at desc\n  limit 1;\n\n  if owner_uid is null then\n    raise exception 'owner with email % not found in auth.users', normalized_email;\n  end if;\n\n  insert into public.accounts(name, frozen)\n  values (clinic_name, false)\n  returning id into acc_id;\n\n  perform public.admin_attach_employee(acc_id, owner_uid, normalized_role);\n\n  update public.account_users\n     set email = normalized_email,\n         role = normalized_role,\n         updated_at = now()\n   where account_id = acc_id\n     and user_uid = owner_uid;\n\n  return acc_id;\nend;\n$$",
      "revoke all on function public.admin_bootstrap_clinic_for_email(text, text, text) from public",
      "grant execute on function public.admin_bootstrap_clinic_for_email(text, text, text) to authenticated",
      "create or replace function public.admin_bootstrap_clinic_for_email(\n  clinic_name text,\n  owner_email text\n)\nreturns uuid\nlanguage plpgsql\nsecurity definer\nset search_path = public, auth\nas $$\nbegin\n  return public.admin_bootstrap_clinic_for_email(clinic_name, owner_email, 'owner');\nend;\n$$",
      "revoke all on function public.admin_bootstrap_clinic_for_email(text, text) from public",
      "grant execute on function public.admin_bootstrap_clinic_for_email(text, text) to authenticated"
    ],
    "name": "fix_admin_bootstrap_loop"
  },
  {
    "version": "20251122090000",
    "statements": [
      "-- 20251122090000_profiles_email_and_disabled.sql\n-- Aligns public.profiles with application expectations (email/disabled columns)\n-- and keeps it in sync with account_users when provisioning new accounts.\n\nBEGIN",
      "ALTER TABLE public.profiles\n  ADD COLUMN IF NOT EXISTS email text,\n  ADD COLUMN IF NOT EXISTS disabled boolean NOT NULL DEFAULT false",
      "CREATE INDEX IF NOT EXISTS profiles_email_lower_idx\n  ON public.profiles (lower(email))",
      "-- backfill email from auth.users when available\nUPDATE public.profiles AS p\nSET email = lower(u.email)\nFROM auth.users u\nWHERE p.email IS NULL\n  AND u.id = p.id",
      "-- backfill disabled flag and restore roles from account_users\nUPDATE public.profiles AS p\nSET disabled = coalesce(au.disabled, false)\nFROM public.account_users au\nWHERE au.user_uid = p.id\n  AND (p.account_id IS NULL OR au.account_id = p.account_id)",
      "UPDATE public.profiles AS p\nSET role = coalesce(au.role, p.role),\n    disabled = true\nFROM public.account_users au\nWHERE au.user_uid = p.id\n  AND (p.account_id IS NULL OR au.account_id = p.account_id)\n  AND lower(coalesce(p.role, '')) = 'disabled'",
      "-- keep profiles in sync with account_users mutations\nCREATE OR REPLACE FUNCTION public.tg_account_users_sync_profile()\nRETURNS trigger\nLANGUAGE plpgsql\nAS $$\nDECLARE\n  target_email text := lower(coalesce(NEW.email, ''));\nBEGIN\n  UPDATE public.profiles AS p\n     SET account_id = NEW.account_id,\n         role = coalesce(NEW.role, p.role),\n         email = CASE WHEN target_email <> '' THEN target_email ELSE p.email END,\n         disabled = coalesce(NEW.disabled, p.disabled)\n   WHERE p.id = NEW.user_uid;\n  RETURN NEW;\nEND;\n$$",
      "DROP TRIGGER IF EXISTS account_users_sync_profile ON public.account_users",
      "CREATE TRIGGER account_users_sync_profile\nAFTER INSERT OR UPDATE ON public.account_users\nFOR EACH ROW\nEXECUTE FUNCTION public.tg_account_users_sync_profile()",
      "-- refresh admin_attach_employee to populate the new fields\nCREATE OR REPLACE FUNCTION public.admin_attach_employee(\n  p_account uuid,\n  p_user_uid uuid,\n  p_role text DEFAULT 'employee'\n) RETURNS void\nLANGUAGE plpgsql\nSECURITY DEFINER\nSET search_path = public\nAS $$\nDECLARE\n  exists_row boolean;\n  caller_can_manage boolean;\n  normalized_role text := coalesce(nullif(trim(p_role), ''), 'employee');\n  normalized_email text;\nBEGIN\n  IF p_account IS NULL OR p_user_uid IS NULL THEN\n    RAISE EXCEPTION 'account_id and user_uid are required';\n  END IF;\n\n  SELECT lower(coalesce(email, ''))\n    INTO normalized_email\n    FROM auth.users\n   WHERE id = p_user_uid\n   ORDER BY created_at DESC\n   LIMIT 1;\n\n  IF fn_is_super_admin() = false THEN\n    SELECT EXISTS (\n             SELECT 1\n               FROM public.account_users au\n              WHERE au.account_id = p_account\n                AND au.user_uid::text = auth.uid()::text\n                AND COALESCE(au.disabled, false) = false\n                AND lower(COALESCE(au.role, '')) = 'owner'\n           )\n      INTO caller_can_manage;\n\n    IF NOT COALESCE(caller_can_manage, false) THEN\n      RAISE EXCEPTION 'insufficient privileges to manage employees for this account'\n        USING ERRCODE = '42501';\n    END IF;\n  END IF;\n\n  SELECT true INTO exists_row\n    FROM public.account_users\n   WHERE account_id = p_account\n     AND user_uid = p_user_uid\n   LIMIT 1;\n\n  IF NOT COALESCE(exists_row, false) THEN\n    INSERT INTO public.account_users(account_id, user_uid, role, disabled, email)\n    VALUES (p_account, p_user_uid, normalized_role, false, nullif(normalized_email, ''));\n  ELSE\n    UPDATE public.account_users\n       SET disabled = false,\n           role = normalized_role,\n           email = COALESCE(nullif(normalized_email, ''), email),\n           updated_at = now()\n     WHERE account_id = p_account\n       AND user_uid = p_user_uid;\n  END IF;\n\n  IF EXISTS (\n    SELECT 1 FROM information_schema.tables\n    WHERE table_schema = 'public' AND table_name = 'profiles'\n  ) THEN\n    INSERT INTO public.profiles(id, account_id, role, email, disabled, created_at)\n    VALUES (\n      p_user_uid,\n      p_account,\n      normalized_role,\n      nullif(normalized_email, ''),\n      false,\n      now()\n    )\n    ON CONFLICT (id) DO UPDATE\n        SET account_id = EXCLUDED.account_id,\n            role = EXCLUDED.role,\n            email = COALESCE(EXCLUDED.email, public.profiles.email),\n            disabled = false;\n  END IF;\nEND;\n$$",
      "REVOKE ALL ON FUNCTION public.admin_attach_employee(uuid, uuid, text) FROM PUBLIC",
      "REVOKE ALL ON FUNCTION public.admin_attach_employee(uuid, uuid, text) FROM anon",
      "GRANT EXECUTE ON FUNCTION public.admin_attach_employee(uuid, uuid, text) TO authenticated",
      "GRANT EXECUTE ON FUNCTION public.admin_attach_employee(uuid, uuid, text) TO service_role",
      "-- keep set_employee_disabled in sync with the new column\nDROP FUNCTION IF EXISTS public.set_employee_disabled(uuid, uuid, boolean)",
      "CREATE OR REPLACE FUNCTION public.set_employee_disabled(\n  p_account uuid,\n  p_user_uid uuid,\n  p_disabled boolean\n) RETURNS void\nLANGUAGE plpgsql\nSECURITY DEFINER\nSET search_path = public, auth\nAS $$\nDECLARE\n  claims jsonb := coalesce(current_setting('request.jwt.claims', true)::jsonb, '{}'::jsonb);\n  caller_uid uuid := nullif(claims->>'sub','')::uuid;\n  can_manage boolean;\n  is_super_admin boolean := public.fn_is_super_admin();\n  target_role text;\nBEGIN\n  SELECT EXISTS (\n    SELECT 1\n      FROM public.account_users\n     WHERE account_id = p_account\n       AND user_uid = caller_uid\n       AND lower(coalesce(role,'')) IN ('owner','admin','superadmin')\n       AND coalesce(disabled,false) = false\n  ) INTO can_manage;\n\n  IF NOT (can_manage OR is_super_admin) THEN\n    RAISE EXCEPTION 'forbidden' USING errcode = '42501';\n  END IF;\n\n  UPDATE public.account_users\n     SET disabled = coalesce(p_disabled, false)\n   WHERE account_id = p_account\n     AND user_uid = p_user_uid;\n\n  SELECT nullif(lower(coalesce(role, '')), '')\n    INTO target_role\n    FROM public.account_users\n   WHERE account_id = p_account\n     AND user_uid = p_user_uid\n   LIMIT 1;\n\n  UPDATE public.profiles\n     SET role = coalesce(target_role, role),\n         account_id = coalesce(account_id, p_account),\n         disabled = coalesce(p_disabled, false)\n   WHERE id = p_user_uid;\nEND;\n$$",
      "REVOKE ALL ON FUNCTION public.set_employee_disabled(uuid, uuid, boolean) FROM public",
      "GRANT EXECUTE ON FUNCTION public.set_employee_disabled(uuid, uuid, boolean) TO authenticated",
      "COMMIT"
    ],
    "name": "profiles_email_and_disabled"
  },
  {
    "version": "20251121060000",
    "statements": [
      "-- 20251121060000_fix_my_profile_security.sql\r\n-- Restores security definer semantics for my_profile() so authenticated users\r\n-- can read their auth.users row without direct table grants.\r\n\r\ncreate or replace function public.my_profile()\r\nreturns table (\r\n  user_uid   uuid,\r\n  email      text,\r\n  account_id uuid,\r\n  role       text,\r\n  disabled   boolean\r\n)\r\nlanguage sql\r\nsecurity definer\r\nstable\r\nset search_path = public, auth\r\nas $$\r\n  with membership as (\r\n    select\r\n      au.account_id,\r\n      au.role::text,\r\n      coalesce(au.disabled, false) as disabled\r\n    from public.account_users au\r\n    where au.user_uid = auth.uid()\r\n    order by au.created_at desc\r\n    limit 1\r\n  )\r\n  select\r\n    u.id as user_uid,\r\n    u.email,\r\n    membership.account_id,\r\n    coalesce(membership.role, 'employee') as role,\r\n    coalesce(membership.disabled, false) as disabled\r\n  from auth.users u\r\n  left join membership on true\r\n  where u.id = auth.uid()\r\n  limit 1;\r\n$$",
      "revoke all on function public.my_profile() from public",
      "grant execute on function public.my_profile() to authenticated"
    ],
    "name": "fix_my_profile_security"
  },
  {
    "version": "20251108090000",
    "statements": [
      "-- 20251108090000_chat_invitation_account_guard.sql\r\n-- Tighten chat invitation acceptance to clinic members and backfill participant account_id.\r\n\r\n-- 1) Ensure participant rows carry the clinic account for RLS/FK alignment\r\nUPDATE public.chat_participants p\r\nSET account_id = c.account_id\r\nFROM public.chat_conversations c\r\nWHERE p.account_id IS NULL\r\n  AND p.conversation_id = c.id",
      "--------------------------------------------------------------------------------\r\n-- 2) Enforce membership during invitation acceptance\r\n--------------------------------------------------------------------------------\r\n\r\nDROP FUNCTION IF EXISTS public.chat_accept_invitation(uuid)",
      "CREATE OR REPLACE FUNCTION public.chat_accept_invitation(p_invitation_id uuid)\r\nRETURNS jsonb\r\nLANGUAGE plpgsql\r\nSECURITY DEFINER\r\nSET search_path = public, auth\r\nAS $$\r\nDECLARE\r\n  v_uid uuid := auth.uid();\r\n  v_email text := lower(coalesce(auth.email(), ''));\r\n  v_inv record;\r\n  v_is_member boolean := false;\r\nBEGIN\r\n  IF v_uid IS NULL THEN\r\n    RAISE EXCEPTION 'not authenticated' USING errcode = '42501';\r\n  END IF;\r\n\r\n  SELECT inv.*, conv.account_id, conv.created_by\r\n  INTO v_inv\r\n  FROM public.chat_group_invitations inv\r\n  JOIN public.chat_conversations conv ON conv.id = inv.conversation_id\r\n  WHERE inv.id = p_invitation_id\r\n  LIMIT 1;\r\n\r\n  IF NOT FOUND THEN\r\n    RAISE EXCEPTION 'invitation not found' USING errcode = 'P0002';\r\n  END IF;\r\n\r\n  IF v_inv.status <> 'pending' THEN\r\n    RETURN jsonb_build_object('ok', false, 'error', 'invitation not pending');\r\n  END IF;\r\n\r\n  IF NOT (\r\n    v_inv.invitee_uid = v_uid\r\n    OR (\r\n      v_inv.invitee_uid IS NULL\r\n      AND v_inv.invitee_email IS NOT NULL\r\n      AND lower(v_inv.invitee_email) = v_email\r\n    )\r\n  ) THEN\r\n    RAISE EXCEPTION 'forbidden' USING errcode = '42501';\r\n  END IF;\r\n\r\n  IF v_inv.account_id IS NOT NULL THEN\r\n    SELECT EXISTS (\r\n      SELECT 1\r\n      FROM public.account_users au\r\n      WHERE au.account_id = v_inv.account_id\r\n        AND au.user_uid = v_uid\r\n        AND coalesce(au.disabled, false) = false\r\n    )\r\n    INTO v_is_member;\r\n\r\n    IF v_is_member = false AND fn_is_super_admin() = false THEN\r\n      RETURN jsonb_build_object('ok', false, 'error', 'invitee not in account');\r\n    END IF;\r\n  END IF;\r\n\r\n  UPDATE public.chat_group_invitations\r\n     SET status = 'accepted',\r\n         invitee_uid = coalesce(v_inv.invitee_uid, v_uid),\r\n         responded_at = now(),\r\n         response_note = NULL\r\n   WHERE id = p_invitation_id;\r\n\r\n  INSERT INTO public.chat_participants (account_id, conversation_id, user_uid, email, joined_at)\r\n  VALUES (\r\n    v_inv.account_id,\r\n    v_inv.conversation_id,\r\n    v_uid,\r\n    NULLIF(v_email, ''),\r\n    now()\r\n  )\r\n  ON CONFLICT (conversation_id, user_uid) DO NOTHING;\r\n\r\n  RETURN jsonb_build_object('ok', true);\r\nEND;\r\n$$",
      "REVOKE ALL ON FUNCTION public.chat_accept_invitation(uuid) FROM PUBLIC",
      "GRANT EXECUTE ON FUNCTION public.chat_accept_invitation(uuid) TO authenticated"
    ],
    "name": "chat_invitation_account_guard"
  },
  {
    "version": "20251107090000",
    "statements": [
      "-- Prevent duplicate invitations per conversation.\r\n-- Adds unique indexes for invitee_uid and invitee_email and cleans existing duplicates.\r\n\r\nDO $$\r\nBEGIN\r\n  -- Remove duplicate rows targeting the same user UID.\r\n  DELETE FROM public.chat_group_invitations a\r\n  USING public.chat_group_invitations b\r\n  WHERE a.id > b.id\r\n    AND a.conversation_id = b.conversation_id\r\n    AND a.invitee_uid IS NOT NULL\r\n    AND b.invitee_uid IS NOT NULL\r\n    AND a.invitee_uid = b.invitee_uid;\r\n\r\n  -- Remove duplicates for email-only invites (no invitee_uid yet).\r\n  DELETE FROM public.chat_group_invitations a\r\n  USING public.chat_group_invitations b\r\n  WHERE a.id > b.id\r\n    AND a.conversation_id = b.conversation_id\r\n    AND a.invitee_uid IS NULL AND b.invitee_uid IS NULL\r\n    AND a.invitee_email IS NOT NULL AND b.invitee_email IS NOT NULL\r\n    AND lower(a.invitee_email) = lower(b.invitee_email);\r\nEND $$",
      "CREATE UNIQUE INDEX IF NOT EXISTS uq_cgi_conversation_invitee_uid\r\n  ON public.chat_group_invitations(conversation_id, invitee_uid)\r\n  WHERE invitee_uid IS NOT NULL",
      "CREATE UNIQUE INDEX IF NOT EXISTS uq_cgi_conversation_invitee_email\r\n  ON public.chat_group_invitations(conversation_id, lower(invitee_email))\r\n  WHERE invitee_uid IS NULL AND invitee_email IS NOT NULL"
    ],
    "name": "chat_group_invitation_uniques"
  },
  {
    "version": "20251106090000",
    "statements": [
      "-- 20251106090000_phase1_backend_fixes.sql\n-- Phase 1 backend fixes:\n--   1) Restore my_feature_permissions(p_account uuid) so the Flutter app can request\n--      feature toggles for the active clinic.\n--   2) Re-enable chat attachment uploads/deletions for conversation participants while\n--      retaining the service_role policy.\n--   3) Align chat_group_invitations with the client expectations and expose helpers\n--      (view + RPCs) for listing/accepting/declining invitations.\n\n--------------------------------------------------------------------------------\n-- 1) my_feature_permissions signature\n--------------------------------------------------------------------------------\n\nDROP FUNCTION IF EXISTS public.my_feature_permissions()",
      "CREATE OR REPLACE FUNCTION public.my_feature_permissions(p_account uuid)\nRETURNS TABLE (\n  account_id       uuid,\n  allowed_features text[],\n  can_create       boolean,\n  can_update       boolean,\n  can_delete       boolean\n)\nLANGUAGE plpgsql\nSECURITY DEFINER\nSET search_path = public, auth\nAS $$\ndeclare\n  v_uid uuid := auth.uid();\n  v_is_super boolean := coalesce(public.fn_is_super_admin(), false)\n    or lower(coalesce(auth.jwt()->>'role', '')) = 'superadmin'\n    or lower(coalesce(auth.jwt()->>'email', '')) = 'admin@elmam.com';\n  v_allowed text[];\n  v_can_create boolean;\n  v_can_update boolean;\n  v_can_delete boolean;\nbegin\n  if v_uid is null then\n    return;\n  end if;\n\n  if p_account is null then\n    return query select null::uuid, array[]::text[], true, true, true;\n  end if;\n\n  if not v_is_super then\n    if not exists (\n      select 1\n      from public.account_users au\n      where au.account_id = p_account\n        and au.user_uid = v_uid\n        and coalesce(au.disabled, false) = false\n    ) then\n      raise exception 'forbidden' using errcode = '42501';\n    end if;\n  end if;\n\n  if not exists (\n    select 1\n    from information_schema.tables\n    where table_schema = 'public' and table_name = 'account_feature_permissions'\n  ) then\n    return query select p_account, array[]::text[], true, true, true;\n  end if;\n\n  select\n    afp.allowed_features,\n    afp.can_create,\n    afp.can_update,\n    afp.can_delete\n  into v_allowed, v_can_create, v_can_update, v_can_delete\n  from public.account_feature_permissions afp\n  where afp.account_id = p_account\n    and (afp.user_uid = v_uid or afp.user_uid is null)\n  order by case when afp.user_uid = v_uid then 0 else 1 end\n  limit 1;\n\n  return query select\n    p_account,\n    coalesce(v_allowed, array[]::text[]),\n    coalesce(v_can_create, true),\n    coalesce(v_can_update, true),\n    coalesce(v_can_delete, true);\nend;\n$$",
      "REVOKE ALL ON FUNCTION public.my_feature_permissions(uuid) FROM PUBLIC",
      "GRANT EXECUTE ON FUNCTION public.my_feature_permissions(uuid) TO authenticated",
      "--------------------------------------------------------------------------------\n-- 2) Storage policies for chat attachments (restore participant access)\n--------------------------------------------------------------------------------\n\nDO $storage$\nDECLARE lacking boolean := false;\nBEGIN\n  BEGIN\n    EXECUTE 'set local role supabase_storage_admin';\n  EXCEPTION\n    WHEN insufficient_privilege THEN\n      lacking := true;\n  END;\n\n  IF lacking THEN\n    RETURN;\n  END IF;\n\n  EXECUTE 'ALTER TABLE storage.objects ENABLE ROW LEVEL SECURITY';\n\n  EXECUTE 'DROP POLICY IF EXISTS chat_attachments_insert_participant ON storage.objects';\n  EXECUTE $q$\n    CREATE POLICY chat_attachments_insert_participant\n    ON storage.objects\n    FOR INSERT\n    TO authenticated\n    WITH CHECK (\n      bucket_id = 'chat-attachments'\n      AND public.chat_conversation_id_from_path(name) IS NOT NULL\n      AND EXISTS (\n        SELECT 1\n        FROM public.chat_participants p\n        WHERE p.conversation_id = public.chat_conversation_id_from_path(name)\n          AND p.user_uid = auth.uid()\n      )\n    );\n  $q$;\n\n  EXECUTE 'DROP POLICY IF EXISTS chat_attachments_delete_participant ON storage.objects';\n  EXECUTE $q$\n    CREATE POLICY chat_attachments_delete_participant\n    ON storage.objects\n    FOR DELETE\n    TO authenticated\n    USING (\n      bucket_id = 'chat-attachments'\n      AND public.chat_conversation_id_from_path(name) IS NOT NULL\n      AND EXISTS (\n        SELECT 1\n        FROM public.chat_participants p\n        WHERE p.conversation_id = public.chat_conversation_id_from_path(name)\n          AND p.user_uid = auth.uid()\n      )\n    );\n  $q$;\n\n  EXECUTE 'reset role';\nEND\n$storage$",
      "--------------------------------------------------------------------------------\n-- 3) Chat group invitations helpers\n--------------------------------------------------------------------------------\n\n-- Rename columns so they align with the Flutter client fields.\nDO $$\nBEGIN\n  IF EXISTS (\n    SELECT 1 FROM information_schema.columns\n    WHERE table_schema = 'public'\n      AND table_name = 'chat_group_invitations'\n      AND column_name = 'inviter'\n  ) THEN\n    EXECUTE 'ALTER TABLE public.chat_group_invitations RENAME COLUMN inviter TO inviter_uid';\n  END IF;\n\n  IF EXISTS (\n    SELECT 1 FROM information_schema.columns\n    WHERE table_schema = 'public'\n      AND table_name = 'chat_group_invitations'\n      AND column_name = 'invitee_user'\n  ) THEN\n    EXECUTE 'ALTER TABLE public.chat_group_invitations RENAME COLUMN invitee_user TO invitee_uid';\n  END IF;\nEND;\n$$",
      "-- View exposing invitations for the current authenticated user.\nCREATE OR REPLACE VIEW public.v_chat_group_invitations_for_me\nWITH (security_invoker = true)\nAS\nSELECT\n  inv.id,\n  inv.conversation_id,\n  inv.inviter_uid,\n  inv.invitee_uid,\n  inv.invitee_email,\n  inv.status,\n  inv.response_note,\n  inv.created_at,\n  inv.responded_at,\n  conv.title,\n  conv.is_group,\n  conv.account_id,\n  conv.created_by\nFROM public.chat_group_invitations inv\nJOIN public.chat_conversations conv ON conv.id = inv.conversation_id\nWHERE (\n    inv.invitee_uid IS NOT NULL AND inv.invitee_uid = auth.uid()\n  ) OR (\n    inv.invitee_uid IS NULL\n    AND inv.invitee_email IS NOT NULL\n    AND lower(inv.invitee_email) = lower(coalesce(auth.email(), ''))\n  )",
      "--------------------------------------------------------------------------------\n-- RPCs: accept / decline\n--------------------------------------------------------------------------------\n\nDROP FUNCTION IF EXISTS public.chat_accept_invitation(uuid)",
      "CREATE OR REPLACE FUNCTION public.chat_accept_invitation(p_invitation_id uuid)\nRETURNS jsonb\nLANGUAGE plpgsql\nSECURITY DEFINER\nSET search_path = public, auth\nAS $$\nDECLARE\n  v_uid uuid := auth.uid();\n  v_email text := lower(coalesce(auth.email(), ''));\n  v_inv record;\nBEGIN\n  IF v_uid IS NULL THEN\n    RAISE EXCEPTION 'not authenticated' USING errcode = '42501';\n  END IF;\n\n  SELECT inv.*, conv.account_id, conv.created_by\n  INTO v_inv\n  FROM public.chat_group_invitations inv\n  JOIN public.chat_conversations conv ON conv.id = inv.conversation_id\n  WHERE inv.id = p_invitation_id\n  LIMIT 1;\n\n  IF NOT FOUND THEN\n    RAISE EXCEPTION 'invitation not found' USING errcode = 'P0002';\n  END IF;\n\n  IF v_inv.status <> 'pending' THEN\n    RETURN jsonb_build_object('ok', false, 'error', 'invitation not pending');\n  END IF;\n\n  IF NOT (\n    v_inv.invitee_uid = v_uid\n    OR (\n      v_inv.invitee_uid IS NULL\n      AND v_inv.invitee_email IS NOT NULL\n      AND lower(v_inv.invitee_email) = v_email\n    )\n  ) THEN\n    RAISE EXCEPTION 'forbidden' USING errcode = '42501';\n  END IF;\n\n  UPDATE public.chat_group_invitations\n     SET status = 'accepted',\n         invitee_uid = coalesce(v_inv.invitee_uid, v_uid),\n         responded_at = now(),\n         response_note = NULL\n   WHERE id = p_invitation_id;\n\n  INSERT INTO public.chat_participants (conversation_id, user_uid, email, joined_at)\n  VALUES (\n    v_inv.conversation_id,\n    v_uid,\n    NULLIF(v_email, ''),\n    now()\n  )\n  ON CONFLICT (conversation_id, user_uid) DO NOTHING;\n\n  RETURN jsonb_build_object('ok', true);\nEND;\n$$",
      "DROP FUNCTION IF EXISTS public.chat_decline_invitation(uuid, text)",
      "CREATE OR REPLACE FUNCTION public.chat_decline_invitation(\n  p_invitation_id uuid,\n  p_note text DEFAULT NULL\n)\nRETURNS jsonb\nLANGUAGE plpgsql\nSECURITY DEFINER\nSET search_path = public, auth\nAS $$\nDECLARE\n  v_uid uuid := auth.uid();\n  v_email text := lower(coalesce(auth.email(), ''));\n  v_inv record;\nBEGIN\n  IF v_uid IS NULL THEN\n    RAISE EXCEPTION 'not authenticated' USING errcode = '42501';\n  END IF;\n\n  SELECT *\n  INTO v_inv\n  FROM public.chat_group_invitations\n  WHERE id = p_invitation_id\n  LIMIT 1;\n\n  IF NOT FOUND THEN\n    RAISE EXCEPTION 'invitation not found' USING errcode = 'P0002';\n  END IF;\n\n  IF NOT (\n    v_inv.invitee_uid = v_uid\n    OR (\n      v_inv.invitee_uid IS NULL\n      AND v_inv.invitee_email IS NOT NULL\n      AND lower(v_inv.invitee_email) = v_email\n    )\n  ) THEN\n    RAISE EXCEPTION 'forbidden' USING errcode = '42501';\n  END IF;\n\n  UPDATE public.chat_group_invitations\n     SET status = 'declined',\n         invitee_uid = coalesce(v_inv.invitee_uid, v_uid),\n         responded_at = now(),\n         response_note = NULLIF(p_note, '')\n   WHERE id = p_invitation_id;\n\n  RETURN jsonb_build_object('ok', true);\nEND;\n$$",
      "REVOKE ALL ON FUNCTION public.chat_accept_invitation(uuid) FROM PUBLIC",
      "GRANT EXECUTE ON FUNCTION public.chat_accept_invitation(uuid) TO authenticated",
      "REVOKE ALL ON FUNCTION public.chat_decline_invitation(uuid, text) FROM PUBLIC",
      "GRANT EXECUTE ON FUNCTION public.chat_decline_invitation(uuid, text) TO authenticated"
    ],
    "name": "phase1_backend_fixes"
  },
  {
    "version": "20251105012000",
    "statements": [
      "-- Fixed migration: chat_group_invitations (no aliases in policies/indexes)\r\n\r\nCREATE EXTENSION IF NOT EXISTS \"pgcrypto\"",
      "-- 1) Enum للحالات (مرة واحدة فقط)\r\nDO $$\r\nBEGIN\r\n  IF NOT EXISTS (\r\n    SELECT 1\r\n    FROM pg_type t\r\n    JOIN pg_namespace n ON n.oid = t.typnamespace\r\n    WHERE n.nspname = 'public' AND t.typname = 'chat_invitation_status'\r\n  ) THEN\r\n    CREATE TYPE public.chat_invitation_status AS ENUM ('pending','accepted','declined','expired');\r\n  END IF;\r\nEND $$",
      "-- 2) الجدول\r\nCREATE TABLE IF NOT EXISTS public.chat_group_invitations (\r\n  id             uuid PRIMARY KEY DEFAULT gen_random_uuid(),\r\n  conversation_id uuid NOT NULL REFERENCES public.chat_conversations(id) ON DELETE CASCADE,\r\n  inviter        uuid NOT NULL,          -- auth.users.id (لا نضع FK لتجنب تعارضات صلاحيات)\r\n  invitee_email  text NOT NULL,\r\n  invitee_user   uuid NULL,              -- auth.users.id (اختياري)\r\n  status         public.chat_invitation_status NOT NULL DEFAULT 'pending',\r\n  response_note  text,\r\n  created_at     timestamptz NOT NULL DEFAULT now(),\r\n  responded_at   timestamptz NULL,\r\n  updated_at     timestamptz NULL\r\n)",
      "-- 3) قيود وفهارس\r\nALTER TABLE public.chat_group_invitations\r\n  DROP CONSTRAINT IF EXISTS chat_group_invitations_email_chk,\r\n  ADD  CONSTRAINT chat_group_invitations_email_chk\r\n       CHECK (position('@' in invitee_email) > 1)",
      "CREATE INDEX IF NOT EXISTS idx_cgi_conversation  ON public.chat_group_invitations(conversation_id)",
      "CREATE INDEX IF NOT EXISTS idx_cgi_invitee_email ON public.chat_group_invitations((lower(invitee_email)))",
      "CREATE INDEX IF NOT EXISTS idx_cgi_status        ON public.chat_group_invitations(status)",
      "CREATE INDEX IF NOT EXISTS idx_cgi_responded     ON public.chat_group_invitations(responded_at)",
      "-- 4) RLS\r\nALTER TABLE public.chat_group_invitations ENABLE ROW LEVEL SECURITY",
      "-- القراءة: الداعي، المدعو، أو أي مشارك في نفس المحادثة\r\nCREATE POLICY chat_group_inv_select\r\n  ON public.chat_group_invitations\r\n  FOR SELECT\r\n  USING (\r\n    inviter = auth.uid()\r\n    OR invitee_user = auth.uid()\r\n    OR EXISTS (\r\n      SELECT 1\r\n      FROM public.chat_participants p\r\n      WHERE p.conversation_id = chat_group_invitations.conversation_id\r\n        AND p.user_uid = auth.uid()\r\n    )\r\n  )",
      "-- الإدخال: فقط من مشارك في نفس المحادثة وباسمه كداعٍ\r\nCREATE POLICY chat_group_inv_insert\r\n  ON public.chat_group_invitations\r\n  FOR INSERT\r\n  WITH CHECK (\r\n    inviter = auth.uid()\r\n    AND EXISTS (\r\n      SELECT 1\r\n      FROM public.chat_participants p\r\n      WHERE p.conversation_id = chat_group_invitations.conversation_id\r\n        AND p.user_uid = auth.uid()\r\n    )\r\n  )",
      "-- التعديل: الداعي أو المدعو\r\nCREATE POLICY chat_group_inv_update\r\n  ON public.chat_group_invitations\r\n  FOR UPDATE\r\n  USING (inviter = auth.uid() OR invitee_user = auth.uid())\r\n  WITH CHECK (inviter = auth.uid() OR invitee_user = auth.uid())",
      "-- الحذف: الداعي فقط\r\nCREATE POLICY chat_group_inv_delete\r\n  ON public.chat_group_invitations\r\n  FOR DELETE\r\n  USING (inviter = auth.uid())",
      "-- 5) Trigger updated_at\r\nDROP TRIGGER IF EXISTS chat_group_invitations_set_updated_at ON public.chat_group_invitations",
      "CREATE TRIGGER chat_group_invitations_set_updated_at\r\nBEFORE UPDATE ON public.chat_group_invitations\r\nFOR EACH ROW\r\nEXECUTE FUNCTION public.tg_set_updated_at()"
    ],
    "name": "chat_group_invitations"
  },
  {
    "version": "20251105011000",
    "statements": [
      "-- 20251105011000_chat_delivery_and_aliases.sql\r\n-- Adds delivery receipts tracking and per-user chat aliases.\r\n\r\n-------------------------------------------------------------------------------\r\n-- Delivery receipts\r\n-------------------------------------------------------------------------------\r\n\r\nCREATE TABLE IF NOT EXISTS public.chat_delivery_receipts (\r\n  message_id uuid NOT NULL REFERENCES public.chat_messages(id) ON DELETE CASCADE,\r\n  conversation_id uuid NOT NULL REFERENCES public.chat_conversations(id) ON DELETE CASCADE,\r\n  user_uid uuid NOT NULL,\r\n  delivered_at timestamptz NOT NULL DEFAULT now(),\r\n  PRIMARY KEY (message_id, user_uid)\r\n)",
      "CREATE INDEX IF NOT EXISTS chat_delivery_receipts_message_idx\r\n  ON public.chat_delivery_receipts (message_id)",
      "CREATE INDEX IF NOT EXISTS chat_delivery_receipts_user_idx\r\n  ON public.chat_delivery_receipts (user_uid)",
      "CREATE INDEX IF NOT EXISTS chat_delivery_receipts_conversation_idx\r\n  ON public.chat_delivery_receipts (conversation_id)",
      "ALTER TABLE public.chat_delivery_receipts ENABLE ROW LEVEL SECURITY",
      "DO $$\r\nBEGIN\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE schemaname = 'public'\r\n      AND tablename = 'chat_delivery_receipts'\r\n      AND policyname = 'delivery_receipts_select_member'\r\n  ) THEN\r\n    CREATE POLICY delivery_receipts_select_member\r\n      ON public.chat_delivery_receipts\r\n      FOR SELECT\r\n      TO authenticated\r\n      USING (\r\n        fn_is_super_admin() = true\r\n        OR EXISTS (\r\n          SELECT 1\r\n          FROM public.chat_participants p\r\n          JOIN public.chat_messages m\r\n            ON m.id = chat_delivery_receipts.message_id\r\n          WHERE p.conversation_id = m.conversation_id\r\n            AND p.user_uid::text = auth.uid()::text\r\n        )\r\n      );\r\n  END IF;\r\nEND $$",
      "DO $$\r\nBEGIN\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE schemaname = 'public'\r\n      AND tablename = 'chat_delivery_receipts'\r\n      AND policyname = 'delivery_receipts_insert_member'\r\n  ) THEN\r\n    CREATE POLICY delivery_receipts_insert_member\r\n      ON public.chat_delivery_receipts\r\n      FOR INSERT\r\n      TO authenticated\r\n      WITH CHECK (\r\n        EXISTS (\r\n          SELECT 1\r\n          FROM public.chat_participants p\r\n          JOIN public.chat_messages m\r\n            ON m.id = chat_delivery_receipts.message_id\r\n          WHERE p.conversation_id = m.conversation_id\r\n            AND p.user_uid::text = auth.uid()::text\r\n            AND chat_delivery_receipts.user_uid = auth.uid()\r\n        )\r\n      );\r\n  END IF;\r\nEND $$",
      "DO $$\r\nBEGIN\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE schemaname = 'public'\r\n      AND tablename = 'chat_delivery_receipts'\r\n      AND policyname = 'delivery_receipts_update_member'\r\n  ) THEN\r\n    CREATE POLICY delivery_receipts_update_member\r\n      ON public.chat_delivery_receipts\r\n      FOR UPDATE\r\n      TO authenticated\r\n      USING (chat_delivery_receipts.user_uid::text = auth.uid()::text);\r\n  END IF;\r\nEND $$",
      "DO $$\r\nBEGIN\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE schemaname = 'public'\r\n      AND tablename = 'chat_delivery_receipts'\r\n      AND policyname = 'delivery_receipts_delete_member'\r\n  ) THEN\r\n    CREATE POLICY delivery_receipts_delete_member\r\n      ON public.chat_delivery_receipts\r\n      FOR DELETE\r\n      TO authenticated\r\n      USING (chat_delivery_receipts.user_uid::text = auth.uid()::text);\r\n  END IF;\r\nEND $$",
      "CREATE OR REPLACE FUNCTION public.chat_mark_delivered(p_message_ids uuid[])\r\nRETURNS void\r\nLANGUAGE plpgsql\r\nSECURITY DEFINER\r\nSET search_path = public\r\nAS $$\r\nDECLARE\r\n  v_uid uuid := auth.uid();\r\nBEGIN\r\n  IF v_uid IS NULL THEN\r\n    RAISE EXCEPTION 'not authorized' USING errcode = '42501';\r\n  END IF;\r\n\r\n  INSERT INTO public.chat_delivery_receipts (message_id, conversation_id, user_uid, delivered_at)\r\n  SELECT DISTINCT mid, m.conversation_id, v_uid, now()\r\n  FROM unnest(coalesce(p_message_ids, ARRAY[]::uuid[])) AS mid\r\n  JOIN public.chat_messages m ON m.id = mid\r\n  WHERE m.sender_uid IS DISTINCT FROM v_uid\r\n  ON CONFLICT (message_id, user_uid)\r\n  DO UPDATE SET delivered_at = EXCLUDED.delivered_at;\r\nEND;\r\n$$",
      "REVOKE ALL ON FUNCTION public.chat_mark_delivered(uuid[]) FROM PUBLIC",
      "GRANT EXECUTE ON FUNCTION public.chat_mark_delivered(uuid[]) TO authenticated",
      "-------------------------------------------------------------------------------\r\n-- Chat aliases\r\n-------------------------------------------------------------------------------\r\n\r\nCREATE TABLE IF NOT EXISTS public.chat_aliases (\r\n  owner_uid uuid NOT NULL,\r\n  target_uid uuid NOT NULL,\r\n  alias text NOT NULL,\r\n  created_at timestamptz NOT NULL DEFAULT now(),\r\n  updated_at timestamptz NOT NULL DEFAULT now(),\r\n  PRIMARY KEY (owner_uid, target_uid)\r\n)",
      "CREATE INDEX IF NOT EXISTS chat_aliases_target_idx\r\n  ON public.chat_aliases (target_uid)",
      "ALTER TABLE public.chat_aliases ENABLE ROW LEVEL SECURITY",
      "CREATE OR REPLACE FUNCTION public.tg_chat_aliases_set_updated_at()\r\nRETURNS trigger\r\nLANGUAGE plpgsql\r\nAS $$\r\nBEGIN\r\n  NEW.updated_at = now();\r\n  RETURN NEW;\r\nEND;\r\n$$",
      "DROP TRIGGER IF EXISTS chat_aliases_set_updated_at ON public.chat_aliases",
      "CREATE TRIGGER chat_aliases_set_updated_at\r\nBEFORE UPDATE ON public.chat_aliases\r\nFOR EACH ROW\r\nEXECUTE FUNCTION public.tg_chat_aliases_set_updated_at()",
      "DO $$\r\nBEGIN\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE schemaname = 'public'\r\n      AND tablename = 'chat_aliases'\r\n      AND policyname = 'chat_aliases_select_owner'\r\n  ) THEN\r\n    CREATE POLICY chat_aliases_select_owner\r\n      ON public.chat_aliases\r\n      FOR SELECT\r\n      TO authenticated\r\n      USING (owner_uid::text = auth.uid()::text);\r\n  END IF;\r\nEND $$",
      "DO $$\r\nBEGIN\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE schemaname = 'public'\r\n      AND tablename = 'chat_aliases'\r\n      AND policyname = 'chat_aliases_manage_owner'\r\n  ) THEN\r\n    CREATE POLICY chat_aliases_manage_owner\r\n      ON public.chat_aliases\r\n      FOR ALL\r\n      TO authenticated\r\n      USING (owner_uid::text = auth.uid()::text)\r\n      WITH CHECK (owner_uid::text = auth.uid()::text);\r\n  END IF;\r\nEND $$"
    ],
    "name": "chat_delivery_and_aliases"
  },
  {
    "version": "20251105010000",
    "statements": [
      "-- 20251105010000_accounts_rls.sql\r\n-- Ensure accounts/account_users expose only permitted rows while remaining\r\n-- queryable by authenticated users (owners, employees, super admins).\r\n\r\nALTER TABLE public.accounts ENABLE ROW LEVEL SECURITY",
      "ALTER TABLE public.account_users ENABLE ROW LEVEL SECURITY",
      "GRANT SELECT ON public.accounts TO authenticated",
      "GRANT SELECT ON public.account_users TO authenticated",
      "DROP POLICY IF EXISTS accounts_select_members ON public.accounts",
      "CREATE POLICY accounts_select_members\r\nON public.accounts\r\nFOR SELECT\r\nTO authenticated\r\nUSING (\r\n  fn_is_super_admin() = true\r\n  OR fn_is_account_member(accounts.id)\r\n)",
      "DROP POLICY IF EXISTS account_users_select ON public.account_users",
      "CREATE POLICY account_users_select\r\nON public.account_users\r\nFOR SELECT\r\nTO authenticated\r\nUSING (\r\n  fn_is_super_admin() = true\r\n  OR account_users.user_uid::text = auth.uid()::text\r\n  OR fn_is_account_member(account_users.account_id)\r\n)"
    ],
    "name": "accounts_rls"
  },
  {
    "version": "20251105005000",
    "statements": [
      "-- 20251105005000_drop_sync_uuid_mapping.sql\r\n-- Remove sync_uuid_mapping from the public schema; the mapping table is managed\r\n-- locally in SQLite and should not live in Supabase (avoids RLS linter errors).\r\n\r\nDROP TABLE IF EXISTS public.sync_uuid_mapping CASCADE"
    ],
    "name": "drop_sync_uuid_mapping"
  },
  {
    "version": "20251104002000",
    "statements": [
      "-- Improve chat query performance for participants/messages lookups.\r\n\r\ncreate index if not exists idx_chat_participants_user_uid\r\n  on public.chat_participants (user_uid)",
      "create index if not exists idx_chat_messages_conversation_created_at\r\n  on public.chat_messages (conversation_id, created_at desc)",
      "create index if not exists idx_account_users_email_lower\r\n  on public.account_users ((lower(email)))"
    ],
    "name": "chat_indexes_fix"
  },
  {
    "version": "20251104001000",
    "statements": [
      "create or replace function public.admin_bootstrap_clinic(\r\n           clinic_name text,\r\n           owner_email text,\r\n           owner_role text default 'owner'\r\n         )\r\n         returns uuid\r\n         language plpgsql\r\n         security definer\r\n         set search_path = public, auth\r\n         as $$\r\n         begin\r\n           return public.admin_bootstrap_clinic_for_email(clinic_name, owner_email, owner_role);\r\n         end;\r\n         $$",
      "revoke all on function public.admin_bootstrap_clinic(text, text, text) from public",
      "grant execute on function public.admin_bootstrap_clinic(text, text, text) to authenticated",
      "grant execute on function public.admin_bootstrap_clinic(text, text, text) to service_role"
    ],
    "name": "fix_admin_bootstrap"
  },
  {
    "version": "20251104000000",
    "statements": [
      "-- Fix admin_create_owner_full ambiguity and provide 2-arg bootstrap wrapper.\r\n\r\ncreate or replace function public.admin_create_owner_full(\r\n  p_clinic_name text,\r\n  p_owner_email text,\r\n  p_owner_password text default null\r\n)\r\nreturns jsonb\r\nlanguage plpgsql\r\nsecurity definer\r\nset search_path = public, auth\r\nas $$\r\ndeclare\r\n  claims jsonb := coalesce(current_setting('request.jwt.claims', true)::jsonb, '{}'::jsonb);\r\n  caller_email text := lower(coalesce(claims->>'email', ''));\r\n  super_admin_email text := 'admin@elmam.com';\r\n  owner_uid uuid;\r\n  v_account_id uuid;\r\nbegin\r\n  if coalesce(trim(p_clinic_name), '') = '' or coalesce(trim(p_owner_email), '') = '' then\r\n    return jsonb_build_object('ok', false, 'error', 'clinic_name and owner_email are required');\r\n  end if;\r\n\r\n  if not (fn_is_super_admin() = true or caller_email = lower(super_admin_email)) then\r\n    raise exception 'forbidden' using errcode = '42501';\r\n  end if;\r\n\r\n  select id\r\n    into owner_uid\r\n  from auth.users\r\n  where lower(email) = lower(p_owner_email)\r\n  order by created_at desc\r\n  limit 1;\r\n\r\n  if owner_uid is null then\r\n    return jsonb_build_object('ok', false, 'error', 'owner user not found');\r\n  end if;\r\n\r\n  insert into public.accounts(name, frozen)\r\n  values (p_clinic_name, false)\r\n  returning id into v_account_id;\r\n\r\n  perform public.admin_attach_employee(v_account_id, owner_uid, 'owner');\r\n\r\n  update public.account_users au\r\n     set email = lower(p_owner_email)\r\n   where au.account_id = v_account_id\r\n     and au.user_uid = owner_uid;\r\n\r\n  return jsonb_build_object('ok', true, 'account_id', v_account_id::text, 'owner_uid', owner_uid::text);\r\nend;\r\n$$",
      "revoke all on function public.admin_create_owner_full(text, text, text) from public",
      "grant execute on function public.admin_create_owner_full(text, text, text) to authenticated",
      "grant execute on function public.admin_create_owner_full(text, text, text) to service_role",
      "create or replace function public.admin_bootstrap_clinic_for_email(\r\n  clinic_name text,\r\n  owner_email text\r\n)\r\nreturns uuid\r\nlanguage plpgsql\r\nsecurity definer\r\nset search_path = public, auth\r\nas $$\r\nbegin\r\n  return public.admin_bootstrap_clinic_for_email(clinic_name, owner_email, 'owner');\r\nend;\r\n$$",
      "revoke all on function public.admin_bootstrap_clinic_for_email(text, text) from public",
      "grant execute on function public.admin_bootstrap_clinic_for_email(text, text) to authenticated",
      "grant execute on function public.admin_bootstrap_clinic_for_email(text, text) to service_role"
    ],
    "name": "fix_admin_create_owner"
  },
  {
    "version": "20251103120000",
    "statements": [
      "-- 20251103120000_chat_participants_flags.sql\r\n-- Add conversation preferences to chat_participants (pinned/archived/blocked/last_read_at/display_name).\r\n\r\nALTER TABLE public.chat_participants\r\n  ADD COLUMN IF NOT EXISTS display_name text",
      "ALTER TABLE public.chat_participants\r\n  ADD COLUMN IF NOT EXISTS pinned boolean",
      "ALTER TABLE public.chat_participants\r\n  ADD COLUMN IF NOT EXISTS archived boolean",
      "ALTER TABLE public.chat_participants\r\n  ADD COLUMN IF NOT EXISTS blocked boolean",
      "ALTER TABLE public.chat_participants\r\n  ADD COLUMN IF NOT EXISTS last_read_at timestamptz",
      "UPDATE public.chat_participants\r\nSET\r\n  pinned = COALESCE(pinned, false),\r\n  archived = COALESCE(archived, false),\r\n  blocked = COALESCE(blocked, false),\r\n  last_read_at = COALESCE(last_read_at, joined_at, timezone('utc', now()))",
      "ALTER TABLE public.chat_participants\r\n  ALTER COLUMN pinned SET DEFAULT false,\r\n  ALTER COLUMN pinned SET NOT NULL,\r\n  ALTER COLUMN archived SET DEFAULT false,\r\n  ALTER COLUMN archived SET NOT NULL,\r\n  ALTER COLUMN blocked SET DEFAULT false,\r\n  ALTER COLUMN blocked SET NOT NULL,\r\n  ALTER COLUMN last_read_at SET DEFAULT timezone('utc', now()),\r\n  ALTER COLUMN last_read_at SET NOT NULL",
      "COMMENT ON COLUMN public.chat_participants.pinned IS 'Pinned conversations for the current participant.'",
      "COMMENT ON COLUMN public.chat_participants.archived IS 'Archived conversations for the current participant.'",
      "COMMENT ON COLUMN public.chat_participants.blocked IS 'Whether the participant blocked notifications from this conversation.'",
      "COMMENT ON COLUMN public.chat_participants.last_read_at IS 'Latest time the participant read the conversation (UTC).'"
    ],
    "name": "chat_participants_flags"
  },
  {
    "version": "20251102100000",
    "statements": [
      "-- 20251102100000_add_item_uuid_to_alert_settings.sql\r\n-- Adds item_uuid column to alert_settings for linking with remote inventory items.\r\n\r\nALTER TABLE IF EXISTS public.alert_settings\r\n  ADD COLUMN IF NOT EXISTS item_uuid uuid",
      "CREATE INDEX IF NOT EXISTS idx_alert_settings_item_uuid\r\n  ON public.alert_settings(item_uuid)"
    ],
    "name": "add_item_uuid_to_alert_settings"
  },
  {
    "version": "20251101080000",
    "statements": [
      "-- 20251101080000_patients_add_doctor_review_columns.sql\r\n-- Adds review tracking columns for doctor confirmation workflow.\r\n\r\nALTER TABLE IF EXISTS public.patients\r\n  ADD COLUMN IF NOT EXISTS doctor_review_pending boolean NOT NULL DEFAULT false",
      "ALTER TABLE IF EXISTS public.patients\r\n  ADD COLUMN IF NOT EXISTS doctor_reviewed_at timestamptz"
    ],
    "name": "patients_add_doctor_review_columns"
  },
  {
    "version": "20251031175216",
    "statements": null,
    "name": "changes_20251031_205216"
  },
  {
    "version": "20251031174700",
    "statements": null,
    "name": "changes_20251031_204659"
  },
  {
    "version": "20251031100500",
    "statements": [
      "-- 20251031100500_account_users_policy_fix.sql\n-- Fix account_users policy recursion by introducing a helper membership function.\n\nCREATE OR REPLACE FUNCTION public.fn_is_account_member(p_account uuid)\nRETURNS boolean\nLANGUAGE sql\nSTABLE\nSECURITY DEFINER\nSET search_path = public\nAS $$\n  SELECT EXISTS (\n    SELECT 1\n    FROM public.account_users au\n    WHERE au.account_id = p_account\n      AND au.user_uid::text = auth.uid()::text\n      AND coalesce(au.disabled, false) = false\n  );\n$$",
      "REVOKE ALL ON FUNCTION public.fn_is_account_member(uuid) FROM PUBLIC",
      "GRANT EXECUTE ON FUNCTION public.fn_is_account_member(uuid) TO authenticated",
      "DROP POLICY IF EXISTS account_users_select ON public.account_users",
      "CREATE POLICY account_users_select\nON public.account_users\nFOR SELECT\nTO authenticated\nUSING (\n  fn_is_super_admin() = true\n  OR account_users.user_uid::text = auth.uid()::text\n  OR fn_is_account_member(account_users.account_id)\n)"
    ],
    "name": "account_users_policy_fix"
  },
  {
    "version": "20251031093000",
    "statements": [
      "-- 20251031093000_fix_consumptions_foreign_keys.sql\n-- Cast legacy text foreign keys to uuid and wire proper constraints.\n\nDO $$\nBEGIN\n  IF EXISTS (\n    SELECT 1\n    FROM information_schema.columns\n    WHERE table_schema = 'public'\n      AND table_name = 'consumptions'\n      AND column_name = 'patient_id'\n      AND data_type = 'text'\n  ) THEN\n    ALTER TABLE public.consumptions\n      ADD COLUMN IF NOT EXISTS patient_id_uuid uuid,\n      ADD COLUMN IF NOT EXISTS item_id_uuid uuid;\n\n    UPDATE public.consumptions\n    SET patient_id_uuid = CASE\n          WHEN patient_id IS NULL OR btrim(patient_id) = '' THEN NULL\n          WHEN patient_id ~* '^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$'\n            THEN patient_id::uuid\n          ELSE NULL\n        END,\n        item_id_uuid = CASE\n          WHEN item_id IS NULL OR btrim(item_id) = '' THEN NULL\n          WHEN item_id ~* '^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$'\n            THEN item_id::uuid\n          ELSE NULL\n        END;\n\n    ALTER TABLE public.consumptions\n      DROP COLUMN patient_id,\n      DROP COLUMN item_id;\n\n    ALTER TABLE public.consumptions\n      RENAME COLUMN patient_id_uuid TO patient_id;\n\n    ALTER TABLE public.consumptions\n      RENAME COLUMN item_id_uuid TO item_id;\n\n    ALTER TABLE public.consumptions\n      ADD CONSTRAINT consumptions_patient_id_fkey\n        FOREIGN KEY (patient_id) REFERENCES public.patients(id)\n        ON DELETE SET NULL;\n\n    ALTER TABLE public.consumptions\n      ADD CONSTRAINT consumptions_item_id_fkey\n        FOREIGN KEY (item_id) REFERENCES public.items(id)\n        ON DELETE SET NULL;\n  END IF;\nEND;\n$$"
    ],
    "name": "fix_consumptions_foreign_keys"
  },
  {
    "version": "20251031090000",
    "statements": [
      "-- 20251031090000_harden_admin_rpcs.sql (fixed)\nDO $$\nDECLARE\n  fn_sig text;\n  targets constant text[] := ARRAY[\n    'public.admin_attach_employee(uuid, uuid, text)',\n    'public.admin_bootstrap_clinic_for_email(text, text, text)',\n    'public.delete_employee(uuid, uuid)',\n    'public.fn_is_super_admin()'\n  ];\nBEGIN\n  FOREACH fn_sig IN ARRAY targets LOOP\n    IF to_regprocedure(fn_sig) IS NOT NULL THEN\n      EXECUTE format('revoke all on function %s from public',        to_regprocedure(fn_sig));\n      EXECUTE format('revoke all on function %s from anon',          to_regprocedure(fn_sig));\n      EXECUTE format('grant execute on function %s to authenticated',to_regprocedure(fn_sig));\n      EXECUTE format('grant execute on function %s to service_role', to_regprocedure(fn_sig));\n    ELSE\n      RAISE NOTICE 'skip harden: function % not found', fn_sig;\n    END IF;\n  END LOOP;\nEND;\n$$"
    ],
    "name": "harden_admin_rpcs"
  },
  {
    "version": "20251030000000",
    "statements": [
      "-- placeholder for remote version 20251030000000"
    ],
    "name": "placeholder"
  },
  {
    "version": "20251027091000",
    "statements": [
      "-- 20251027091000_seed_super_admin.sql\n-- Seed default super admin email.\n\nINSERT INTO public.super_admins(email)\nVALUES ('admin@elmam.com')\nON CONFLICT (email) DO NOTHING"
    ],
    "name": "seed_super_admin"
  },
  {
    "version": "20251027090500",
    "statements": [
      "-- 20251027090500_enable_pg_trgm.sql\n-- Ensure pg_trgm is available without requiring superuser privileges.\n\nDO $$\nBEGIN\n  IF EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'pg_trgm') THEN\n    RAISE NOTICE 'pg_trgm already enabled';\n  ELSE\n    RAISE NOTICE 'pg_trgm not enabled. Enable it from Supabase Dashboard → Database → Extensions.';\n  END IF;\nEND;\n$$"
    ],
    "name": "enable_pg_trgm"
  },
  {
    "version": "20251026000000",
    "statements": [
      "-- 20251026000000_staff_user_uid.sql\r\n-- Adds user_uid tracking columns for employees/doctors and keeps helper RPCs aligned.\r\n\r\nALTER TABLE public.doctors\r\n  ADD COLUMN IF NOT EXISTS user_uid uuid",
      "ALTER TABLE public.employees\r\n  ADD COLUMN IF NOT EXISTS user_uid uuid",
      "CREATE UNIQUE INDEX IF NOT EXISTS doctors_user_uid_key\r\n  ON public.doctors(user_uid)\r\n  WHERE user_uid IS NOT NULL",
      "CREATE UNIQUE INDEX IF NOT EXISTS employees_user_uid_key\r\n  ON public.employees(user_uid)\r\n  WHERE user_uid IS NOT NULL",
      "-- Ensure admin_attach_employee honors the new constraint.\r\nCREATE OR REPLACE FUNCTION public.admin_attach_employee(\r\n  p_account uuid,\r\n  p_user_uid uuid,\r\n  p_role text DEFAULT 'employee'\r\n)\r\nRETURNS void\r\nLANGUAGE plpgsql\r\nSECURITY DEFINER\r\nAS $$\r\nDECLARE\r\n  exists_row boolean;\r\nBEGIN\r\n  IF p_account IS NULL OR p_user_uid IS NULL THEN\r\n    RAISE EXCEPTION 'account_id and user_uid are required';\r\n  END IF;\r\n\r\n  IF EXISTS (\r\n    SELECT 1\r\n    FROM public.employees e\r\n    WHERE e.user_uid = p_user_uid\r\n      AND e.account_id IS DISTINCT FROM p_account\r\n  ) THEN\r\n    RAISE EXCEPTION 'user already linked to another employee record' USING errcode = '23505';\r\n  END IF;\r\n\r\n  IF EXISTS (\r\n    SELECT 1\r\n    FROM public.doctors d\r\n    WHERE d.user_uid = p_user_uid\r\n      AND d.account_id IS DISTINCT FROM p_account\r\n  ) THEN\r\n    RAISE EXCEPTION 'user already linked to another doctor record' USING errcode = '23505';\r\n  END IF;\r\n\r\n  SELECT true INTO exists_row\r\n  FROM public.account_users\r\n  WHERE account_id = p_account\r\n    AND user_uid = p_user_uid\r\n  LIMIT 1;\r\n\r\n  IF NOT COALESCE(exists_row, false) THEN\r\n    INSERT INTO public.account_users(account_id, user_uid, role, disabled)\r\n    VALUES (p_account, p_user_uid, COALESCE(p_role, 'employee'), false);\r\n  ELSE\r\n    UPDATE public.account_users\r\n       SET disabled = false,\r\n           role = COALESCE(p_role, role),\r\n           updated_at = now()\r\n     WHERE account_id = p_account\r\n       AND user_uid = p_user_uid;\r\n  END IF;\r\n\r\n  IF EXISTS (\r\n    SELECT 1 FROM information_schema.tables\r\n    WHERE table_schema='public' AND table_name='profiles'\r\n  ) THEN\r\n    INSERT INTO public.profiles(id, account_id, role, created_at)\r\n    VALUES (p_user_uid, p_account, COALESCE(p_role, 'employee'), now())\r\n    ON CONFLICT (id) DO UPDATE\r\n        SET account_id = EXCLUDED.account_id,\r\n            role = EXCLUDED.role;\r\n  END IF;\r\nEND;\r\n$$",
      "-- Expand list_employees_with_email to expose link status.\r\nDROP FUNCTION IF EXISTS public.list_employees_with_email(uuid)",
      "CREATE OR REPLACE FUNCTION public.list_employees_with_email(p_account uuid)\r\nRETURNS TABLE(\r\n  user_uid uuid,\r\n  email text,\r\n  role text,\r\n  disabled boolean,\r\n  created_at timestamptz,\r\n  employee_id uuid,\r\n  doctor_id uuid\r\n) AS $$\r\nDECLARE\r\n  claims jsonb := coalesce(current_setting('request.jwt.claims', true)::jsonb, '{}'::jsonb);\r\n  caller_uid uuid := nullif(claims->>'sub','')::uuid;\r\n  caller_email text := lower(coalesce(claims->>'email',''));\r\n  super_admin_email text := 'admin@elmam.com';\n  can_manage boolean;\r\nBEGIN\r\n  SELECT EXISTS (\r\n    SELECT 1\r\n    FROM public.account_users\r\n    WHERE account_id = p_account\r\n      AND user_uid = caller_uid\r\n      AND role IN ('owner','admin')\r\n      AND coalesce(disabled,false) = false\r\n  ) INTO can_manage;\r\n\r\n  IF NOT (can_manage OR caller_email = lower(super_admin_email)) THEN\r\n    RAISE EXCEPTION 'forbidden' USING errcode = '42501';\r\n  END IF;\r\n\r\n  RETURN QUERY\r\n  SELECT\r\n    au.user_uid,\r\n    coalesce(u.email, au.email),\r\n    au.role,\r\n    coalesce(au.disabled,false) AS disabled,\r\n    au.created_at,\r\n    e.id AS employee_id,\r\n    d.id AS doctor_id\r\n  FROM public.account_users au\r\n  LEFT JOIN auth.users u ON u.id = au.user_uid\r\n  LEFT JOIN public.employees e ON e.account_id = au.account_id AND e.user_uid = au.user_uid\r\n  LEFT JOIN public.doctors d ON d.account_id = au.account_id AND d.user_uid = au.user_uid\r\n  WHERE au.account_id = p_account\r\n  ORDER BY au.created_at DESC;\r\nEND;\r\n$$ LANGUAGE plpgsql\r\nSECURITY DEFINER\r\nSET search_path = public, auth",
      "GRANT EXECUTE ON FUNCTION public.list_employees_with_email(uuid) TO authenticated",
      "-- When removing a link, clear the staff user reference so it can be reused.\r\nCREATE OR REPLACE FUNCTION public.delete_employee(\r\n  p_account uuid,\r\n  p_user_uid uuid\r\n)\r\nRETURNS void AS $$\r\nDECLARE\r\n  claims jsonb := coalesce(current_setting('request.jwt.claims', true)::jsonb, '{}'::jsonb);\r\n  caller_uid uuid := nullif(claims->>'sub','')::uuid;\r\n  caller_email text := lower(coalesce(claims->>'email',''));\r\n  super_admin_email text := 'admin@elmam.com';\n  can_manage boolean;\r\nBEGIN\r\n  SELECT EXISTS (\r\n    SELECT 1\r\n    FROM public.account_users\r\n    WHERE account_id = p_account\r\n      AND user_uid = caller_uid\r\n      AND role IN ('owner','admin')\r\n      AND coalesce(disabled,false) = false\r\n  ) INTO can_manage;\r\n\r\n  IF NOT (can_manage OR caller_email = lower(super_admin_email)) THEN\r\n    RAISE EXCEPTION 'forbidden' USING errcode = '42501';\r\n  END IF;\r\n\r\n  DELETE FROM public.account_users\r\n   WHERE account_id = p_account\r\n     AND user_uid = p_user_uid;\r\n\r\n  UPDATE public.employees\r\n     SET user_uid = NULL,\r\n         updated_at = now()\r\n   WHERE account_id = p_account\r\n     AND user_uid = p_user_uid;\r\n\r\n  UPDATE public.doctors\r\n     SET user_uid = NULL,\r\n         updated_at = now()\r\n   WHERE account_id = p_account\r\n     AND user_uid = p_user_uid;\r\n\r\n  UPDATE public.profiles\r\n     SET role = 'removed'\r\n   WHERE id = p_user_uid\r\n     AND coalesce(account_id, p_account) = p_account;\r\nEND;\r\n$$ LANGUAGE plpgsql\r\nSECURITY DEFINER\r\nSET search_path = public, auth"
    ],
    "name": "staff_user_uid"
  },
  {
    "version": "20251025080000",
    "statements": [
      "---------------------------\r\n-- 1) إصلاح العروض: security_invoker\r\n---------------------------\r\nALTER VIEW public.v_chat_last_message                 SET (security_invoker = true)",
      "ALTER VIEW public.v_chat_messages_with_attachments    SET (security_invoker = true)",
      "ALTER VIEW public.v_chat_reads_for_me                 SET (security_invoker = true)",
      "ALTER VIEW public.v_chat_conversations_for_me         SET (security_invoker = true)",
      "ALTER VIEW public.clinics                             SET (security_invoker = true)",
      "---------------------------\r\n-- 2) super_admins: تفعيل RLS + سياسات\r\n---------------------------\r\nALTER TABLE public.super_admins ENABLE ROW LEVEL SECURITY",
      "DO $$\r\nBEGIN\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE schemaname='public' AND tablename='super_admins' AND policyname='super_admins_select_self'\r\n  ) THEN\r\n    CREATE POLICY super_admins_select_self\r\n    ON public.super_admins\r\n    FOR SELECT\r\n    TO authenticated\r\n    USING (user_uid = auth.uid());\r\n  END IF;\r\n\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE schemaname='public' AND tablename='super_admins' AND policyname='super_admins_read_service'\r\n  ) THEN\r\n    CREATE POLICY super_admins_read_service\r\n    ON public.super_admins\r\n    FOR SELECT\r\n    TO service_role\r\n    USING (true);\r\n  END IF;\r\n\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE schemaname='public' AND tablename='super_admins' AND policyname='super_admins_write_service'\r\n  ) THEN\r\n    CREATE POLICY super_admins_write_service\r\n    ON public.super_admins\r\n    FOR ALL\r\n    TO service_role\r\n    USING (true)\r\n    WITH CHECK (true);\r\n  END IF;\r\nEND$$",
      "---------------------------\r\n-- 3) إنشاء جدول account_feature_permissions إن كان مفقودًا\r\n---------------------------\r\nDO $$\nDECLARE\n  r record;\nBEGIN\n  FOR r IN\n    SELECT p.oid::regprocedure AS sig\n    FROM pg_proc p\n    JOIN pg_namespace n ON n.oid = p.pronamespace\n    WHERE n.nspname = 'public'\n      AND p.proname IN (\n        'admin_set_clinic_frozen',\n        'admin_create_owner_full',\n        'admin_create_employee_full',\n        'admin_delete_clinic',\n        'admin_attach_employee',\n        'admin_bootstrap_clinic_for_email',\n        'admin_list_clinics'\n      )\n  LOOP\n    EXECUTE format('DROP FUNCTION IF EXISTS %s', r.sig);\n  END LOOP;\nEND;\n$$",
      "CREATE TABLE IF NOT EXISTS public.account_feature_permissions (\n  id               uuid PRIMARY KEY DEFAULT gen_random_uuid(),\r\n  account_id       uuid NOT NULL,\r\n  user_uid         uuid NOT NULL,\r\n  allowed_features text[] NOT NULL DEFAULT '{}',\r\n  can_create       boolean NOT NULL DEFAULT true,\r\n  can_update       boolean NOT NULL DEFAULT true,\r\n  can_delete       boolean NOT NULL DEFAULT true,\r\n  created_at       timestamptz NOT NULL DEFAULT now(),\r\n  updated_at       timestamptz NOT NULL DEFAULT now()\r\n)",
      "CREATE UNIQUE INDEX IF NOT EXISTS account_feature_permissions_uix\r\n  ON public.account_feature_permissions (account_id, user_uid)",
      "-- (اختياري) علاقات مرجعية إن كانت موجودة لديك\r\n-- ALTER TABLE public.account_feature_permissions\r\n--   ADD CONSTRAINT account_feature_permissions_account_fk\r\n--   FOREIGN KEY (account_id) REFERENCES public.accounts(id) ON DELETE CASCADE;\r\n\r\nALTER TABLE public.account_feature_permissions ENABLE ROW LEVEL SECURITY",
      "CREATE OR REPLACE FUNCTION public.tg_account_feature_permissions_touch()\r\nRETURNS trigger\r\nLANGUAGE plpgsql\r\nAS $$\r\nBEGIN\r\n  NEW.updated_at = now();\r\n  RETURN NEW;\r\nEND;\r\n$$",
      "DROP TRIGGER IF EXISTS account_feature_permissions_touch ON public.account_feature_permissions",
      "CREATE TRIGGER account_feature_permissions_touch\r\nBEFORE UPDATE ON public.account_feature_permissions\r\nFOR EACH ROW\r\nEXECUTE FUNCTION public.tg_account_feature_permissions_touch()",
      "DO $$\r\nBEGIN\r\n  -- قراءة المالك/العضو أو السوبر أدمن\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE schemaname='public' AND tablename='account_feature_permissions' AND policyname='afp_select_members'\r\n  ) THEN\r\n    CREATE POLICY afp_select_members\r\n    ON public.account_feature_permissions\r\n    FOR SELECT\r\n    TO authenticated\r\n    USING (\r\n      EXISTS (\r\n        SELECT 1 FROM public.account_users au\r\n        WHERE au.account_id = account_feature_permissions.account_id\r\n          AND au.user_uid   = auth.uid()\r\n      )\r\n      OR EXISTS (SELECT 1 FROM public.super_admins sa WHERE sa.user_uid = auth.uid())\r\n    );\r\n  END IF;\r\n\r\n  -- إدارة الصلاحيات للمالكين/المديرين أو السوبر أدمن\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE schemaname='public' AND tablename='account_feature_permissions' AND policyname='afp_manage_account_admins_insert'\r\n  ) THEN\r\n    CREATE POLICY afp_manage_account_admins_insert\r\n    ON public.account_feature_permissions\r\n    FOR INSERT\r\n    TO authenticated\r\n    WITH CHECK (\r\n      fn_is_super_admin() = true\r\n      OR EXISTS (\r\n        SELECT 1 FROM public.account_users au\r\n        WHERE au.account_id = account_feature_permissions.account_id\r\n          AND au.user_uid   = auth.uid()\r\n          AND coalesce(au.disabled, false) = false\r\n          AND lower(coalesce(au.role, '')) IN ('owner','admin','superadmin')\r\n      )\r\n    );\r\n  END IF;\r\n\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE schemaname='public' AND tablename='account_feature_permissions' AND policyname='afp_manage_account_admins_update'\r\n  ) THEN\r\n    CREATE POLICY afp_manage_account_admins_update\r\n    ON public.account_feature_permissions\r\n    FOR UPDATE\r\n    TO authenticated\r\n    USING (\r\n      fn_is_super_admin() = true\r\n      OR EXISTS (\r\n        SELECT 1 FROM public.account_users au\r\n        WHERE au.account_id = account_feature_permissions.account_id\r\n          AND au.user_uid   = auth.uid()\r\n          AND coalesce(au.disabled, false) = false\r\n          AND lower(coalesce(au.role, '')) IN ('owner','admin','superadmin')\r\n      )\r\n    )\r\n    WITH CHECK (\r\n      fn_is_super_admin() = true\r\n      OR EXISTS (\r\n        SELECT 1 FROM public.account_users au\r\n        WHERE au.account_id = account_feature_permissions.account_id\r\n          AND au.user_uid   = auth.uid()\r\n          AND coalesce(au.disabled, false) = false\r\n          AND lower(coalesce(au.role, '')) IN ('owner','admin','superadmin')\r\n      )\r\n    );\r\n  END IF;\r\n\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE schemaname='public' AND tablename='account_feature_permissions' AND policyname='afp_manage_account_admins_delete'\r\n  ) THEN\r\n    CREATE POLICY afp_manage_account_admins_delete\r\n    ON public.account_feature_permissions\r\n    FOR DELETE\r\n    TO authenticated\r\n    USING (\r\n      fn_is_super_admin() = true\r\n      OR EXISTS (\r\n        SELECT 1 FROM public.account_users au\r\n        WHERE au.account_id = account_feature_permissions.account_id\r\n          AND au.user_uid   = auth.uid()\r\n          AND coalesce(au.disabled, false) = false\r\n          AND lower(coalesce(au.role, '')) IN ('owner','admin','superadmin')\r\n      )\r\n    );\r\n  END IF;\r\n\r\n  -- كتابة عبر service_role فقط\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE schemaname='public' AND tablename='account_feature_permissions' AND policyname='afp_write_service'\r\n  ) THEN\r\n    CREATE POLICY afp_write_service\r\n    ON public.account_feature_permissions\r\n    FOR ALL\r\n    TO service_role\r\n    USING (true)\r\n    WITH CHECK (true);\r\n  END IF;\r\nEND$$",
      "---------------------------\r\n-- 4) RPCs مطلوبة من الواجهة\r\n---------------------------\r\n\r\n-- يعيد الملف الشخصي للحساب الحالي\r\nCREATE OR REPLACE FUNCTION public.my_profile()\r\nRETURNS TABLE (\r\n  user_uid   uuid,\r\n  email      text,\r\n  account_id uuid,\r\n  role       text,\r\n  disabled   boolean\r\n)\r\nLANGUAGE sql\r\nSECURITY INVOKER\r\nSTABLE\r\nAS $$\r\n  SELECT u.id,\r\n         u.email,\r\n         au.account_id,\r\n         au.role::text,\r\n         au.disabled\r\n  FROM auth.users u\r\n  JOIN public.account_users au ON au.user_uid = u.id\r\n  WHERE u.id = auth.uid()\r\n  LIMIT 1;\r\n$$",
      "-- أذونات الميزات للمستخدم داخل حسابه الحالي\r\nCREATE OR REPLACE FUNCTION public.my_feature_permissions()\r\nRETURNS TABLE (\r\n  account_id       uuid,\r\n  allowed_features text[],\r\n  can_create       boolean,\r\n  can_update       boolean,\r\n  can_delete       boolean\r\n)\r\nLANGUAGE sql\r\nSECURITY INVOKER\r\nSTABLE\r\nAS $$\r\n  SELECT\r\n    coalesce(afp.account_id, au.account_id) as account_id,\r\n    coalesce(afp.allowed_features, '{}')    as allowed_features,\r\n    coalesce(afp.can_create, true)          as can_create,\r\n    coalesce(afp.can_update, true)          as can_update,\r\n    coalesce(afp.can_delete, true)          as can_delete\r\n  FROM public.account_users au\r\n  LEFT JOIN public.account_feature_permissions afp\r\n    ON afp.account_id = au.account_id AND afp.user_uid = au.user_uid\r\n  WHERE au.user_uid = auth.uid()\r\n  LIMIT 1;\r\n$$",
      "---------------------------\r\n-- 5) Storage: bucket وسياسات مرفقات الدردشة\r\n---------------------------\r\nINSERT INTO storage.buckets (id, name, public)\nVALUES ('chat-attachments','chat-attachments', false)\nON CONFLICT (id) DO NOTHING",
      "DO $storage$\nDECLARE lacking boolean := false;\nBEGIN\n  BEGIN\n    EXECUTE 'set local role supabase_storage_admin';\n  EXCEPTION\n    WHEN insufficient_privilege THEN\n      lacking := true;\n  END;\n\n  IF lacking THEN\n    RETURN;\n  END IF;\n\n  EXECUTE 'ALTER TABLE storage.objects ENABLE ROW LEVEL SECURITY';\n\n  EXECUTE $q$DROP POLICY IF EXISTS chat_read_by_participants ON storage.objects$q$;\n  EXECUTE $q$\n    CREATE POLICY chat_read_by_participants\n    ON storage.objects\n    FOR SELECT\n    TO authenticated\n    USING (\n      bucket_id = 'chat-attachments'\n      AND EXISTS (\n        SELECT 1\n        FROM public.chat_attachments a\n        JOIN public.chat_messages m ON m.id = a.message_id\n        JOIN public.chat_participants p ON p.conversation_id = m.conversation_id\n        WHERE a.bucket = 'chat-attachments'\n          AND a.path   = storage.objects.name\n          AND p.user_uid = auth.uid()\n      )\n    );\n  $q$;\n\n  EXECUTE $q$DROP POLICY IF EXISTS chat_write_service_only ON storage.objects$q$;\n  EXECUTE $q$\n    CREATE POLICY chat_write_service_only\n    ON storage.objects\n    FOR ALL\n    TO service_role\n    USING (bucket_id = 'chat-attachments')\n    WITH CHECK (bucket_id = 'chat-attachments');\n  $q$;\n\n  EXECUTE 'reset role';\nEND\n$storage$",
      "---------------------------\r\n-- 6) نشر Realtime لكل جداول public (تدريجيًا)\r\n---------------------------\r\nDO $$\nDECLARE\n  r record;\nBEGIN\n  BEGIN\n    FOR r IN SELECT tablename FROM pg_tables WHERE schemaname='public' LOOP\n      BEGIN\n        EXECUTE format('ALTER PUBLICATION supabase_realtime ADD TABLE public.%I', r.tablename);\n      EXCEPTION\n        WHEN duplicate_object THEN\n          -- الجدول مضاف مسبقًا إلى الـ publication، نتجاهل الخطأ.\n          NULL;\n      END;\n    END LOOP;\n  EXCEPTION\n    WHEN undefined_object THEN\n      -- publication missing, skip\n      NULL;\n  END;\nEND;\n$$",
      "---------------------------\r\n-- 7) chat_participants: أعمدة email/joined_at للتماشي مع التطبيق\r\n---------------------------\r\nALTER TABLE public.chat_participants\r\n  ADD COLUMN IF NOT EXISTS email text",
      "ALTER TABLE public.chat_participants\r\n  ADD COLUMN IF NOT EXISTS joined_at timestamptz",
      "UPDATE public.chat_participants AS cp\nSET joined_at = COALESCE(cp.joined_at, cc.created_at, now())\nFROM public.chat_conversations AS cc\nWHERE cp.conversation_id = cc.id\n  AND cp.joined_at IS NULL",
      "ALTER TABLE public.chat_participants\r\n  ALTER COLUMN joined_at SET DEFAULT now()",
      "ALTER TABLE public.chat_participants\r\n  ALTER COLUMN joined_at SET NOT NULL",
      "---------------------------\r\n-- 8) إنشاء جدول audit_logs وسياسات القراءة\r\n---------------------------\r\nCREATE TABLE IF NOT EXISTS public.audit_logs (\r\n  id          bigserial PRIMARY KEY,\r\n  account_id  uuid NOT NULL,\r\n  actor_uid   uuid,\r\n  actor_email text,\r\n  table_name  text NOT NULL,\r\n  op          text NOT NULL,\r\n  row_pk      text,\r\n  before_row  jsonb,\r\n  after_row   jsonb,\r\n  diff        jsonb,\r\n  created_at  timestamptz NOT NULL DEFAULT now()\r\n)",
      "CREATE INDEX IF NOT EXISTS audit_logs_account_created_idx\r\n  ON public.audit_logs (account_id, created_at DESC)",
      "CREATE INDEX IF NOT EXISTS audit_logs_table_idx\r\n  ON public.audit_logs (table_name)",
      "CREATE INDEX IF NOT EXISTS audit_logs_actor_idx\r\n  ON public.audit_logs (actor_uid)",
      "ALTER TABLE public.audit_logs ENABLE ROW LEVEL SECURITY",
      "GRANT SELECT ON TABLE public.audit_logs TO authenticated",
      "GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE public.audit_logs TO service_role",
      "DO $$\r\nBEGIN\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE schemaname='public' AND tablename='audit_logs' AND policyname='audit_logs_select_account_members'\r\n  ) THEN\r\n    CREATE POLICY audit_logs_select_account_members\r\n    ON public.audit_logs\r\n    FOR SELECT\r\n    TO authenticated\r\n    USING (\r\n      fn_is_super_admin() = true\r\n      OR EXISTS (\r\n        SELECT 1 FROM public.account_users au\r\n        WHERE au.account_id = audit_logs.account_id\r\n          AND au.user_uid = auth.uid()\r\n          AND coalesce(au.disabled, false) = false\r\n      )\r\n    );\r\n  END IF;\r\n\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE schemaname='public' AND tablename='audit_logs' AND policyname='audit_logs_service_all'\r\n  ) THEN\r\n    CREATE POLICY audit_logs_service_all\r\n    ON public.audit_logs\r\n    FOR ALL\r\n    TO service_role\r\n    USING (true)\r\n    WITH CHECK (true);\r\n  END IF;\r\nEND$$",
      "---------------------------\r\n-- 9) إجراءات مساعدة للإدارة (RPC)\r\n---------------------------\r\n\r\nCREATE OR REPLACE FUNCTION public.admin_list_clinics()\r\nRETURNS TABLE (\r\n  id uuid,\r\n  name text,\r\n  frozen boolean,\r\n  created_at timestamptz\r\n)\r\nLANGUAGE plpgsql\r\nSECURITY DEFINER\r\nSET search_path = public, auth\r\nAS $$\r\nDECLARE\r\n  claims jsonb := coalesce(current_setting('request.jwt.claims', true)::jsonb, '{}'::jsonb);\r\n  caller_email text := lower(coalesce(claims->>'email', ''));\r\n  super_admin_email text := 'admin@elmam.com';\nBEGIN\r\n  IF NOT (fn_is_super_admin() = true OR caller_email = lower(super_admin_email)) THEN\r\n    RAISE EXCEPTION 'forbidden' USING errcode = '42501';\r\n  END IF;\r\n\r\n  RETURN QUERY\r\n  SELECT a.id, a.name, a.frozen, a.created_at\r\n  FROM public.accounts a\r\n  ORDER BY a.created_at DESC;\r\nEND;\r\n$$",
      "REVOKE ALL ON FUNCTION public.admin_list_clinics() FROM public",
      "GRANT EXECUTE ON FUNCTION public.admin_list_clinics() TO authenticated",
      "CREATE OR REPLACE FUNCTION public.admin_set_clinic_frozen(\r\n  p_account_id uuid,\r\n  p_frozen boolean\r\n)\r\nRETURNS jsonb\r\nLANGUAGE plpgsql\r\nSECURITY DEFINER\r\nSET search_path = public, auth\r\nAS $$\r\nDECLARE\r\n  claims jsonb := coalesce(current_setting('request.jwt.claims', true)::jsonb, '{}'::jsonb);\r\n  caller_email text := lower(coalesce(claims->>'email', ''));\r\n  super_admin_email text := 'admin@elmam.com';\n  updated_id uuid;\r\nBEGIN\r\n  IF p_account_id IS NULL THEN\r\n    RETURN jsonb_build_object('ok', false, 'error', 'account_id is required');\r\n  END IF;\r\n\r\n  IF NOT (fn_is_super_admin() = true OR caller_email = lower(super_admin_email)) THEN\r\n    RAISE EXCEPTION 'forbidden' USING errcode = '42501';\r\n  END IF;\r\n\r\n  UPDATE public.accounts\r\n     SET frozen = coalesce(p_frozen, false)\r\n   WHERE id = p_account_id\r\n   RETURNING id INTO updated_id;\r\n\r\n  IF updated_id IS NULL THEN\r\n    RETURN jsonb_build_object('ok', false, 'error', 'account not found');\r\n  END IF;\r\n\r\n  RETURN jsonb_build_object('ok', true, 'account_id', updated_id::text, 'frozen', coalesce(p_frozen, false));\r\nEND;\r\n$$",
      "REVOKE ALL ON FUNCTION public.admin_set_clinic_frozen(uuid, boolean) FROM public",
      "GRANT EXECUTE ON FUNCTION public.admin_set_clinic_frozen(uuid, boolean) TO authenticated",
      "CREATE OR REPLACE FUNCTION public.admin_delete_clinic(\r\n  p_account_id uuid\r\n)\r\nRETURNS jsonb\r\nLANGUAGE plpgsql\r\nSECURITY DEFINER\r\nSET search_path = public, auth\r\nAS $$\r\nDECLARE\r\n  claims jsonb := coalesce(current_setting('request.jwt.claims', true)::jsonb, '{}'::jsonb);\r\n  caller_email text := lower(coalesce(claims->>'email', ''));\r\n  super_admin_email text := 'admin@elmam.com';\n  deleted_id uuid;\r\nBEGIN\r\n  IF p_account_id IS NULL THEN\r\n    RETURN jsonb_build_object('ok', false, 'error', 'account_id is required');\r\n  END IF;\r\n\r\n  IF NOT (fn_is_super_admin() = true OR caller_email = lower(super_admin_email)) THEN\r\n    RAISE EXCEPTION 'forbidden' USING errcode = '42501';\r\n  END IF;\r\n\r\n  DELETE FROM public.accounts\r\n   WHERE id = p_account_id\r\n   RETURNING id INTO deleted_id;\r\n\r\n  IF deleted_id IS NULL THEN\r\n    RETURN jsonb_build_object('ok', false, 'error', 'account not found');\r\n  END IF;\r\n\r\n  RETURN jsonb_build_object('ok', true, 'account_id', deleted_id::text);\r\nEND;\r\n$$",
      "REVOKE ALL ON FUNCTION public.admin_delete_clinic(uuid) FROM public",
      "GRANT EXECUTE ON FUNCTION public.admin_delete_clinic(uuid) TO authenticated",
      "CREATE OR REPLACE FUNCTION public.admin_create_owner_full(\r\n  p_clinic_name text,\r\n  p_owner_email text,\r\n  p_owner_password text DEFAULT NULL\r\n)\r\nRETURNS jsonb\r\nLANGUAGE plpgsql\r\nSECURITY DEFINER\r\nSET search_path = public, auth\r\nAS $$\r\nDECLARE\r\n  claims jsonb := coalesce(current_setting('request.jwt.claims', true)::jsonb, '{}'::jsonb);\r\n  caller_email text := lower(coalesce(claims->>'email', ''));\r\n  super_admin_email text := 'admin@elmam.com';\n  owner_uid uuid;\r\n  account_id uuid;\r\nBEGIN\r\n  IF coalesce(trim(p_clinic_name), '') = '' OR coalesce(trim(p_owner_email), '') = '' THEN\r\n    RETURN jsonb_build_object('ok', false, 'error', 'clinic_name and owner_email are required');\r\n  END IF;\r\n\r\n  IF NOT (fn_is_super_admin() = true OR caller_email = lower(super_admin_email)) THEN\r\n    RAISE EXCEPTION 'forbidden' USING errcode = '42501';\r\n  END IF;\r\n\r\n  SELECT id\r\n    INTO owner_uid\r\n  FROM auth.users\r\n  WHERE lower(email) = lower(p_owner_email)\r\n  ORDER BY created_at DESC\r\n  LIMIT 1;\r\n\r\n  IF owner_uid IS NULL THEN\r\n    RETURN jsonb_build_object('ok', false, 'error', 'owner user not found');\r\n  END IF;\r\n\r\n  INSERT INTO public.accounts(name, frozen)\r\n  VALUES (p_clinic_name, false)\r\n  RETURNING id INTO account_id;\r\n\r\n  PERFORM public.admin_attach_employee(account_id, owner_uid, 'owner');\r\n\r\n  UPDATE public.account_users au\r\n     SET email = lower(p_owner_email)\r\n   WHERE au.account_id = account_id\r\n     AND au.user_uid = owner_uid;\r\n\r\n  RETURN jsonb_build_object('ok', true, 'account_id', account_id::text, 'owner_uid', owner_uid::text);\r\nEND;\r\n$$",
      "REVOKE ALL ON FUNCTION public.admin_create_owner_full(text, text, text) FROM public",
      "GRANT EXECUTE ON FUNCTION public.admin_create_owner_full(text, text, text) TO authenticated",
      "CREATE OR REPLACE FUNCTION public.admin_create_employee_full(\r\n  p_account uuid,\r\n  p_email text,\r\n  p_password text DEFAULT NULL\r\n)\r\nRETURNS jsonb\r\nLANGUAGE plpgsql\r\nSECURITY DEFINER\r\nSET search_path = public, auth\r\nAS $$\r\nDECLARE\r\n  claims jsonb := coalesce(current_setting('request.jwt.claims', true)::jsonb, '{}'::jsonb);\r\n  caller_uid uuid := nullif(claims->>'sub', '')::uuid;\r\n  caller_email text := lower(coalesce(claims->>'email', ''));\r\n  super_admin_email text := 'admin@elmam.com';\n  can_manage boolean;\r\n  employee_uid uuid;\r\nBEGIN\r\n  IF p_account IS NULL OR coalesce(trim(p_email), '') = '' THEN\r\n    RETURN jsonb_build_object('ok', false, 'error', 'account and email are required');\r\n  END IF;\r\n\r\n  SELECT EXISTS (\r\n    SELECT 1\r\n    FROM public.account_users au\r\n    WHERE au.account_id = p_account\r\n      AND au.user_uid = caller_uid\r\n      AND au.role IN ('owner', 'admin')\r\n      AND coalesce(au.disabled, false) = false\r\n  ) INTO can_manage;\r\n\r\n  IF NOT (fn_is_super_admin() = true OR can_manage OR caller_email = lower(super_admin_email)) THEN\r\n    RAISE EXCEPTION 'forbidden' USING errcode = '42501';\r\n  END IF;\r\n\r\n  SELECT id\r\n    INTO employee_uid\r\n  FROM auth.users\r\n  WHERE lower(email) = lower(p_email)\r\n  ORDER BY created_at DESC\r\n  LIMIT 1;\r\n\r\n  IF employee_uid IS NULL THEN\r\n    RETURN jsonb_build_object('ok', false, 'error', 'user not found');\r\n  END IF;\r\n\r\n  PERFORM public.admin_attach_employee(p_account, employee_uid, 'employee');\r\n\r\n  UPDATE public.account_users\r\n     SET email = coalesce(email, lower(p_email))\r\n   WHERE account_id = p_account\r\n     AND user_uid = employee_uid;\r\n\r\n  RETURN jsonb_build_object('ok', true, 'account_id', p_account::text, 'user_uid', employee_uid::text);\r\nEND;\r\n$$",
      "REVOKE ALL ON FUNCTION public.admin_create_employee_full(uuid, text, text) FROM public",
      "GRANT EXECUTE ON FUNCTION public.admin_create_employee_full(uuid, text, text) TO authenticated",
      "CREATE OR REPLACE FUNCTION public.chat_admin_start_dm(\r\n  target_email text\r\n)\r\nRETURNS uuid\r\nLANGUAGE plpgsql\r\nSECURITY DEFINER\r\nSET search_path = public, auth\r\nAS $$\r\nDECLARE\r\n  claims jsonb := coalesce(current_setting('request.jwt.claims', true)::jsonb, '{}'::jsonb);\r\n  caller_uid uuid := nullif(claims->>'sub', '')::uuid;\r\n  caller_email text := lower(coalesce(claims->>'email', ''));\r\n  super_admin_email text := 'admin@elmam.com';\n  normalized_email text := lower(coalesce(target_email, ''));\r\n  target_uid uuid;\r\n  target_account uuid;\r\n  existing_conv uuid;\r\n  conv_id uuid;\r\n  now_ts timestamptz := now();\r\nBEGIN\r\n  IF caller_uid IS NULL THEN\r\n    RAISE EXCEPTION 'forbidden' USING errcode = '42501';\r\n  END IF;\r\n\r\n  IF normalized_email = '' THEN\r\n    RAISE EXCEPTION 'target_email is required';\r\n  END IF;\r\n\r\n  IF NOT (fn_is_super_admin() = true OR caller_email = lower(super_admin_email)) THEN\r\n    RAISE EXCEPTION 'forbidden' USING errcode = '42501';\r\n  END IF;\r\n\r\n  SELECT id\r\n    INTO target_uid\r\n  FROM auth.users\r\n  WHERE lower(email) = normalized_email\r\n  ORDER BY created_at DESC\r\n  LIMIT 1;\r\n\r\n  IF target_uid IS NULL THEN\r\n    RAISE EXCEPTION 'target user not found' USING errcode = 'P0002';\r\n  END IF;\r\n\r\n  IF target_uid = caller_uid THEN\r\n    RAISE EXCEPTION 'cannot start conversation with yourself';\r\n  END IF;\r\n\r\n  SELECT au.account_id\r\n    INTO target_account\r\n  FROM public.account_users au\r\n  WHERE au.user_uid = target_uid\r\n    AND coalesce(au.disabled, false) = false\r\n  ORDER BY CASE WHEN lower(coalesce(au.role, '')) IN ('owner','admin','superadmin') THEN 0 ELSE 1 END,\r\n           au.created_at DESC\r\n  LIMIT 1;\r\n\r\n  SELECT p.conversation_id\r\n    INTO existing_conv\r\n  FROM public.chat_participants p\r\n  JOIN public.chat_participants p2\r\n    ON p.conversation_id = p2.conversation_id\r\n  JOIN public.chat_conversations c\r\n    ON c.id = p.conversation_id\r\n  WHERE p.user_uid = caller_uid\r\n    AND p2.user_uid = target_uid\r\n    AND coalesce(c.is_group, false) = false\r\n  ORDER BY c.created_at DESC\r\n  LIMIT 1;\r\n\r\n  IF existing_conv IS NOT NULL THEN\r\n    RETURN existing_conv;\r\n  END IF;\r\n\r\n  conv_id := gen_random_uuid();\r\n\r\n  INSERT INTO public.chat_conversations(id, account_id, is_group, title, created_by, created_at, updated_at)\r\n  VALUES (conv_id, target_account, false, NULL, caller_uid, now_ts, now_ts);\r\n\r\n  INSERT INTO public.chat_participants(conversation_id, user_uid, role, email, joined_at)\r\n  VALUES\r\n    (conv_id, caller_uid, 'superadmin', NULLIF(caller_email, ''), now_ts),\r\n    (conv_id, target_uid, NULL, normalized_email, now_ts);\r\n\r\n  RETURN conv_id;\r\nEND;\r\n$$",
      "REVOKE ALL ON FUNCTION public.chat_admin_start_dm(text) FROM public",
      "GRANT EXECUTE ON FUNCTION public.chat_admin_start_dm(text) TO authenticated"
    ],
    "name": "patch"
  },
  {
    "version": "20251025079900",
    "statements": [
      "-- 20251025079900_drop_super_rpcs_for_redefine.sql\n-- Drops legacy definitions so 20251025080000_patch.sql can redefine them with new OUT columns.\n\nDROP FUNCTION IF EXISTS public.admin_list_clinics()",
      "DROP FUNCTION IF EXISTS public.my_feature_permissions(uuid)"
    ],
    "name": "drop_super_rpcs_for_redefine"
  },
  {
    "version": "20251025079800",
    "statements": [
      "-- 20251025079800_drop_my_profile_for_patch.sql\n-- Drops the existing my_profile signature so 20251025080000_patch.sql can redefine it.\n\nDROP FUNCTION IF EXISTS public.my_profile()"
    ],
    "name": "drop_my_profile_for_patch"
  },
  {
    "version": "20251025070000",
    "statements": [
      "-- add codegen helper functions (fixed)\ncreate or replace function public.get_enum_types()\nreturns table(name text, labels text[])\nlanguage sql stable as $$\n  select t.typname::text as name,\n         array_agg(e.enumlabel order by e.enumsortorder)::text[] as labels\n  from pg_type t\n  join pg_enum e on e.enumtypid = t.oid\n  join pg_namespace n on n.oid = t.typnamespace\n  where n.nspname in ('public')\n  group by t.typname\n  order by t.typname;\n$$",
      "create or replace function public.get_schema_info()\nreturns jsonb\nlanguage sql stable as $$\nwith tbls as (\n  select table_schema, table_name\n  from information_schema.tables\n  where table_schema in ('public') and table_type = 'BASE TABLE'\n),\ncols as (\n  select table_schema, table_name, column_name, data_type, udt_name,\n         is_nullable, is_generated, column_default, ordinal_position\n  from information_schema.columns\n  where table_schema in ('public')\n),\npks as (\n  select kcu.table_schema, kcu.table_name, kcu.column_name, kcu.ordinal_position\n  from information_schema.table_constraints tc\n  join information_schema.key_column_usage kcu\n    on tc.constraint_name = kcu.constraint_name\n   and tc.table_schema   = kcu.table_schema\n  where tc.constraint_type = 'PRIMARY KEY'\n    and tc.table_schema in ('public')\n),\nfks as (\n  select tc.table_schema,\n         tc.table_name,\n         kcu.column_name,\n         ccu.table_schema as foreign_table_schema,\n         ccu.table_name   as foreign_table_name,\n         ccu.column_name  as foreign_column_name\n  from information_schema.table_constraints tc\n  join information_schema.key_column_usage kcu\n    on tc.constraint_name = kcu.constraint_name\n   and tc.table_schema   = kcu.table_schema\n  join information_schema.constraint_column_usage ccu\n    on ccu.constraint_name = tc.constraint_name\n   and ccu.table_schema   = tc.table_schema\n  where tc.constraint_type = 'FOREIGN KEY'\n    and tc.table_schema in ('public')\n),\nenums as (\n  select name, labels from public.get_enum_types()\n)\nselect jsonb_build_object(\n  'tables', (\n    select coalesce(\n      jsonb_agg(jsonb_build_object('schema', s.table_schema, 'name', s.table_name)),\n      '[]'::jsonb\n    )\n    from (\n      select distinct t.table_schema, t.table_name\n      from tbls t\n      order by t.table_schema, t.table_name\n    ) s\n  ),\n  'columns', (\n    select coalesce(jsonb_agg(jsonb_build_object(\n      'schema', c.table_schema,\n      'table',  c.table_name,\n      'name',   c.column_name,\n      'data_type', c.data_type,\n      'udt_name',  c.udt_name,\n      'is_nullable', c.is_nullable = 'YES',\n      'is_generated', c.is_generated,\n      'default', c.column_default\n    ) order by c.table_schema, c.table_name, c.ordinal_position), '[]'::jsonb)\n    from cols c\n  ),\n  'primary_keys', (\n    select coalesce(jsonb_agg(jsonb_build_object(\n      'schema', p.table_schema, 'table', p.table_name, 'column', p.column_name\n    ) order by p.table_schema, p.table_name, p.column_name), '[]'::jsonb)\n    from pks p\n  ),\n  'foreign_keys', (\n    select coalesce(jsonb_agg(jsonb_build_object(\n      'schema', f.table_schema, 'table', f.table_name, 'column', f.column_name,\n      'foreign_schema', f.foreign_table_schema,\n      'foreign_table',  f.foreign_table_name,\n      'foreign_column', f.foreign_column_name\n    ) order by f.table_schema, f.table_name, f.column_name), '[]'::jsonb)\n    from fks f\n  ),\n  'enums', (\n    select coalesce(jsonb_agg(jsonb_build_object(\n      'name', e.name, 'labels', e.labels\n    )), '[]'::jsonb)\n    from enums e\n  )\n);\n$$",
      "-- refresh PostgREST cache\nnotify pgrst, 'reload schema'"
    ],
    "name": "add_codegen_functions"
  },
  {
    "version": "20251025000000",
    "statements": [
      "-- add updated_at if missing and make it NOT NULL with default now()\nALTER TABLE public.profiles\n  ADD COLUMN IF NOT EXISTS updated_at timestamptz",
      "UPDATE public.profiles\nSET updated_at = COALESCE(updated_at, created_at, now())",
      "ALTER TABLE public.profiles\n  ALTER COLUMN updated_at SET DEFAULT now(),\n  ALTER COLUMN updated_at SET NOT NULL",
      "-- ensure function exists\nCREATE OR REPLACE FUNCTION public.tg_profiles_set_updated_at()\nRETURNS trigger\nLANGUAGE plpgsql\nAS $$\nBEGIN\n  NEW.updated_at := now();\n  RETURN NEW;\nEND;\n$$",
      "-- ensure trigger exists\nDO $$\nBEGIN\n  IF NOT EXISTS (\n    SELECT 1\n    FROM pg_trigger t\n    JOIN pg_class c ON c.oid=t.tgrelid\n    WHERE c.relname='profiles' AND t.tgname='profiles_set_updated_at'\n  ) THEN\n    CREATE TRIGGER profiles_set_updated_at\n    BEFORE UPDATE ON public.profiles\n    FOR EACH ROW\n    EXECUTE FUNCTION public.tg_profiles_set_updated_at();\n  END IF;\nEND $$"
    ],
    "name": "profiles_add_updated_at"
  },
  {
    "version": "20250924000000",
    "statements": [
      "-- Deploy admin_attach_employee hardening to existing environments\r\nBEGIN",
      "CREATE OR REPLACE FUNCTION public.admin_attach_employee(p_account uuid, p_user_uid uuid, p_role text DEFAULT 'employee')\r\nRETURNS void\r\nLANGUAGE plpgsql\r\nSECURITY DEFINER\r\nSET search_path = public\r\nAS $$\r\nDECLARE\r\n  exists_row boolean;\r\n  caller_can_manage boolean;\r\nBEGIN\r\n  IF p_account IS NULL OR p_user_uid IS NULL THEN\r\n    RAISE EXCEPTION 'account_id and user_uid are required';\r\n  END IF;\r\n\r\n  IF fn_is_super_admin() = false THEN\r\n    SELECT EXISTS (\r\n             SELECT 1\r\n               FROM public.account_users au\r\n              WHERE au.account_id = p_account\r\n                AND au.user_uid::text = auth.uid()::text\r\n                AND COALESCE(au.disabled, false) = false\r\n                AND lower(COALESCE(au.role, '')) = 'owner'\r\n           )\r\n      INTO caller_can_manage;\r\n\r\n    IF NOT COALESCE(caller_can_manage, false) THEN\r\n      RAISE EXCEPTION 'insufficient privileges to manage employees for this account'\r\n        USING ERRCODE = '42501';\r\n    END IF;\r\n  END IF;\r\n\r\n  SELECT true INTO exists_row\r\n  FROM public.account_users\r\n  WHERE account_id = p_account\r\n    AND user_uid = p_user_uid\r\n  LIMIT 1;\r\n\r\n  IF NOT COALESCE(exists_row, false) THEN\r\n    INSERT INTO public.account_users(account_id, user_uid, role, disabled)\r\n    VALUES (p_account, p_user_uid, COALESCE(p_role, 'employee'), false);\r\n  ELSE\r\n    UPDATE public.account_users\r\n       SET disabled = false,\r\n           role = COALESCE(p_role, role),\r\n           updated_at = now()\r\n     WHERE account_id = p_account\r\n       AND user_uid = p_user_uid;\r\n  END IF;\r\n\r\n  IF EXISTS (\r\n    SELECT 1 FROM information_schema.tables\r\n    WHERE table_schema = 'public' AND table_name = 'profiles'\r\n  ) THEN\r\n    INSERT INTO public.profiles(id, account_id, role, created_at)\r\n    VALUES (p_user_uid, p_account, COALESCE(p_role, 'employee'), now())\r\n    ON CONFLICT (id) DO UPDATE\r\n        SET account_id = EXCLUDED.account_id,\r\n            role = EXCLUDED.role;\r\n  END IF;\r\nEND;\r\n$$",
      "REVOKE ALL ON FUNCTION public.admin_attach_employee(uuid, uuid, text) FROM PUBLIC",
      "REVOKE ALL ON FUNCTION public.admin_attach_employee(uuid, uuid, text) FROM anon",
      "GRANT EXECUTE ON FUNCTION public.admin_attach_employee(uuid, uuid, text) TO authenticated",
      "GRANT EXECUTE ON FUNCTION public.admin_attach_employee(uuid, uuid, text) TO service_role",
      "COMMIT"
    ],
    "name": "admin_attach_employee_redeploy"
  },
  {
    "version": "20250923000000",
    "statements": [
      "-- 20250923000000_profiles_table.sql\r\n-- Creates the public.profiles table required by edge/admin functions and client fallbacks.\r\n-- Ensures RLS policies align with account permissions and super admin overrides.\r\n\r\nCREATE TABLE IF NOT EXISTS public.profiles (\r\n  id uuid PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,\r\n  account_id uuid REFERENCES public.accounts(id) ON DELETE SET NULL,\r\n  role text NOT NULL DEFAULT 'employee',\r\n  display_name text,\r\n  created_at timestamptz NOT NULL DEFAULT now(),\r\n  updated_at timestamptz NOT NULL DEFAULT now()\r\n)",
      "CREATE INDEX IF NOT EXISTS profiles_account_idx ON public.profiles(account_id)",
      "-- keep updated_at fresh\r\nCREATE OR REPLACE FUNCTION public.tg_profiles_set_updated_at()\r\nRETURNS trigger\r\nLANGUAGE plpgsql\r\nAS $$\r\nBEGIN\r\n  NEW.updated_at = now();\r\n  RETURN NEW;\r\nEND;\r\n$$",
      "DROP TRIGGER IF EXISTS profiles_set_updated_at ON public.profiles",
      "CREATE TRIGGER profiles_set_updated_at\r\nBEFORE UPDATE ON public.profiles\r\nFOR EACH ROW\r\nEXECUTE FUNCTION public.tg_profiles_set_updated_at()",
      "ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY",
      "GRANT SELECT, INSERT, UPDATE, DELETE ON public.profiles TO authenticated",
      "-- policies: allow super admin, account managers, or the profile owner\r\nDO $$\r\nBEGIN\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE schemaname = 'public' AND tablename = 'profiles' AND policyname = 'profiles_select_own_or_account'\r\n  ) THEN\r\n    CREATE POLICY profiles_select_own_or_account\r\n      ON public.profiles\r\n      FOR SELECT TO authenticated\r\n      USING (\r\n        fn_is_super_admin() = true\r\n        OR id::text = auth.uid()::text\r\n        OR (\r\n          account_id IS NOT NULL AND EXISTS (\r\n            SELECT 1 FROM public.account_users au\r\n            WHERE au.account_id = profiles.account_id\r\n              AND au.user_uid::text = auth.uid()::text\r\n              AND coalesce(au.disabled, false) = false\r\n          )\r\n        )\r\n      );\r\n  END IF;\r\nEND $$",
      "DO $$\r\nBEGIN\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE schemaname = 'public' AND tablename = 'profiles' AND policyname = 'profiles_insert_account_managers'\r\n  ) THEN\r\n    CREATE POLICY profiles_insert_account_managers\r\n      ON public.profiles\r\n      FOR INSERT TO authenticated\r\n      WITH CHECK (\r\n        fn_is_super_admin() = true\r\n        OR (\r\n          account_id IS NOT NULL AND EXISTS (\r\n            SELECT 1 FROM public.account_users au\r\n            WHERE au.account_id = profiles.account_id\r\n              AND au.user_uid::text = auth.uid()::text\r\n              AND coalesce(au.disabled, false) = false\r\n              AND lower(coalesce(au.role, '')) IN ('owner','admin','superadmin')\r\n          )\r\n        )\r\n      );\r\n  END IF;\r\nEND $$",
      "DO $$\r\nBEGIN\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE schemaname = 'public' AND tablename = 'profiles' AND policyname = 'profiles_update_account_managers'\r\n  ) THEN\r\n    CREATE POLICY profiles_update_account_managers\r\n      ON public.profiles\r\n      FOR UPDATE TO authenticated\r\n      USING (\r\n        fn_is_super_admin() = true\r\n        OR id::text = auth.uid()::text\r\n        OR (\r\n          account_id IS NOT NULL AND EXISTS (\r\n            SELECT 1 FROM public.account_users au\r\n            WHERE au.account_id = profiles.account_id\r\n              AND au.user_uid::text = auth.uid()::text\r\n              AND coalesce(au.disabled, false) = false\r\n              AND lower(coalesce(au.role, '')) IN ('owner','admin','superadmin')\r\n          )\r\n        )\r\n      )\r\n      WITH CHECK (\r\n        fn_is_super_admin() = true\r\n        OR id::text = auth.uid()::text\r\n        OR (\r\n          account_id IS NOT NULL AND EXISTS (\r\n            SELECT 1 FROM public.account_users au\r\n            WHERE au.account_id = profiles.account_id\r\n              AND au.user_uid::text = auth.uid()::text\r\n              AND coalesce(au.disabled, false) = false\r\n              AND lower(coalesce(au.role, '')) IN ('owner','admin','superadmin')\r\n          )\r\n        )\r\n      );\r\n  END IF;\r\nEND $$",
      "DO $$\r\nBEGIN\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE schemaname = 'public' AND tablename = 'profiles' AND policyname = 'profiles_delete_account_managers'\r\n  ) THEN\r\n    CREATE POLICY profiles_delete_account_managers\r\n      ON public.profiles\r\n      FOR DELETE TO authenticated\r\n      USING (\r\n        fn_is_super_admin() = true\r\n        OR (\r\n          account_id IS NOT NULL AND EXISTS (\r\n            SELECT 1 FROM public.account_users au\r\n            WHERE au.account_id = profiles.account_id\r\n              AND au.user_uid::text = auth.uid()::text\r\n              AND coalesce(au.disabled, false) = false\r\n              AND lower(coalesce(au.role, '')) IN ('owner','admin','superadmin')\r\n          )\r\n        )\r\n      );\r\n  END IF;\r\nEND $$"
    ],
    "name": "profiles_table"
  },
  {
    "version": "2025092102",
    "statements": [
      "-- 2025092102_storage_chat_attachments.sql\n-- Storage policies for the chat-attachments bucket, executed with the proper owner role.\n\ncreate or replace function public.chat_conversation_id_from_path(_name text)\nreturns uuid\nlanguage sql\nimmutable\nas $$\n  select case\n           when regexp_match(_name,\n             '^attachments/([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})/'\n           ) is null\n           then null\n           else ((regexp_match(_name,\n             '^attachments/([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})/'\n           ))[1])::uuid\n         end\n$$",
      "do $$\nbegin\n  begin\n    execute 'alter table storage.objects enable row level security';\n  exception\n    when insufficient_privilege then null;\n  end;\nend $$",
      "do $policies$\nbegin\n  begin\n    execute 'set local role supabase_storage_admin';\n  exception\n    when insufficient_privilege then\n      -- On Supabase Cloud the linked service role cannot impersonate the storage owner.\n      -- Skip silently; policies must be managed via the dashboard in that environment.\n      return;\n  end;\n\n  execute 'drop policy if exists \"chat-attachments read for participants\" on storage.objects';\n  execute $$\n    create policy \"chat-attachments read for participants\"\n    on storage.objects\n    for select\n    to authenticated\n    using (\n      bucket_id = 'chat-attachments'\n      and exists (\n        select 1\n        from public.chat_participants p\n        where p.conversation_id = public.chat_conversation_id_from_path(name)\n          and p.user_uid = auth.uid()\n      )\n    );\n  $$;\n\n  execute 'drop policy if exists \"chat-attachments insert for participants\" on storage.objects';\n  execute $$\n    create policy \"chat-attachments insert for participants\"\n    on storage.objects\n    for insert\n    to authenticated\n    with check (\n      bucket_id = 'chat-attachments'\n      and exists (\n        select 1\n        from public.chat_participants p\n        where p.conversation_id = public.chat_conversation_id_from_path(name)\n          and p.user_uid = auth.uid()\n      )\n    );\n  $$;\n\n  execute 'drop policy if exists \"chat-attachments delete for participants\" on storage.objects';\n  execute $$\n    create policy \"chat-attachments delete for participants\"\n    on storage.objects\n    for delete\n    to authenticated\n    using (\n      bucket_id = 'chat-attachments'\n      and exists (\n        select 1\n        from public.chat_participants p\n        where p.conversation_id = public.chat_conversation_id_from_path(name)\n          and p.user_uid = auth.uid()\n      )\n    );\n  $$;\n\n  execute 'reset role';\nend\n$policies$"
    ],
    "name": "storage_chat_attachments"
  },
  {
    "version": "2025092101",
    "statements": [
      "-- 20250921_publication_add_chat_reactions.sql\r\n-- إضافة جدول التفاعلات إلى Publication الخاصة بـ Realtime\r\n\r\nDO $$\r\nBEGIN\r\n  -- نتأكد أن الـ publication موجودة (Supabase ينشئ supabase_realtime افتراضيًا)\r\n  IF EXISTS (\r\n    SELECT 1 FROM pg_publication WHERE pubname = 'supabase_realtime'\r\n  ) THEN\r\n    -- قد يفشل إذا كان الجدول مضافًا مسبقًا، لذا نحاصر بالاستثناء\r\n    BEGIN\r\n      ALTER PUBLICATION supabase_realtime ADD TABLE public.chat_reactions;\r\n    EXCEPTION\r\n      WHEN duplicate_object THEN\r\n        -- موجود بالفعل؛ نتجاهل\r\n        NULL;\r\n    END;\r\n  END IF;\r\nEND$$"
    ],
    "name": "publication_add_chat_reactions"
  },
  {
    "version": "20250921000000",
    "statements": [
      "-- 20250921_chat_reactions.sql\r\n-- جدول التفاعلات على الرسائل + سياسات RLS للمشاركين فقط + فهارس\r\n\r\n-- 1) الجدول\r\n-- ملاحظة: بافتراض أن chat_messages.id من نوع UUID.\r\n-- إن كان نوعه TEXT لديك، غيّر النوع أدناه ليتطابق مع مخططك (وأزل FK أو عدّله).\r\nCREATE TABLE IF NOT EXISTS public.chat_reactions (\r\n  message_id uuid NOT NULL REFERENCES public.chat_messages(id) ON DELETE CASCADE,\r\n  user_uid  uuid NOT NULL, -- يطابق auth.uid(); لا نضع FK على auth.users لتفادي صلاحيات عبر المخططات\r\n  emoji     text NOT NULL CHECK (char_length(emoji) BETWEEN 1 AND 16),\r\n  created_at timestamptz NOT NULL DEFAULT now(),\r\n  PRIMARY KEY (message_id, user_uid, emoji)\r\n)",
      "-- 2) تمكين RLS\r\nALTER TABLE public.chat_reactions ENABLE ROW LEVEL SECURITY",
      "-- 3) سياسة SELECT — أي مشارك في نفس المحادثة التي تنتمي لها الرسالة\r\nDROP POLICY IF EXISTS \"reactions select for participants\" ON public.chat_reactions",
      "CREATE POLICY \"reactions select for participants\"\r\nON public.chat_reactions\r\nFOR SELECT\r\nTO authenticated\r\nUSING (\r\n  EXISTS (\r\n    SELECT 1\r\n    FROM public.chat_messages m\r\n    JOIN public.chat_participants p\r\n      ON p.conversation_id = m.conversation_id\r\n     AND p.user_uid = auth.uid()\r\n    WHERE m.id = chat_reactions.message_id\r\n  )\r\n)",
      "-- 4) سياسة INSERT — يجب أن يكون المُدخل مشاركًا، وباسمه فقط (user_uid = auth.uid())\r\nDROP POLICY IF EXISTS \"reactions insert by participant self\" ON public.chat_reactions",
      "CREATE POLICY \"reactions insert by participant self\"\r\nON public.chat_reactions\r\nFOR INSERT\r\nTO authenticated\r\nWITH CHECK (\r\n  user_uid = auth.uid()\r\n  AND EXISTS (\r\n    SELECT 1\r\n    FROM public.chat_messages m\r\n    JOIN public.chat_participants p\r\n      ON p.conversation_id = m.conversation_id\r\n     AND p.user_uid = auth.uid()\r\n    WHERE m.id = chat_reactions.message_id\r\n  )\r\n)",
      "-- 5) سياسة DELETE — فقط صاحب التفاعل، ويجب أن يكون مشاركًا\r\nDROP POLICY IF EXISTS \"reactions delete by owner participant\" ON public.chat_reactions",
      "CREATE POLICY \"reactions delete by owner participant\"\r\nON public.chat_reactions\r\nFOR DELETE\r\nTO authenticated\r\nUSING (\r\n  user_uid = auth.uid()\r\n  AND EXISTS (\r\n    SELECT 1\r\n    FROM public.chat_messages m\r\n    JOIN public.chat_participants p\r\n      ON p.conversation_id = m.conversation_id\r\n     AND p.user_uid = auth.uid()\r\n    WHERE m.id = chat_reactions.message_id\r\n  )\r\n)",
      "-- لا نسمح بـ UPDATE (غير مطلوب وظيفيًا). إن رغبت لاحقًا، أضف سياسة مماثلة.\r\n\r\n-- 6) فهارس/تحسينات\r\n-- المفتاح الأساسي يكفي لاسترجاع حسب message_id، لكن نضيف فهرسًا مُركّزًا اختياريًا للاستخدامات التحليلية\r\nCREATE INDEX IF NOT EXISTS chat_reactions_user_created_idx\r\n  ON public.chat_reactions (user_uid, created_at DESC)"
    ],
    "name": "chat_reactions"
  },
  {
    "version": "20250920",
    "statements": [
      "-- 20250920_chat_indexes.sql\n-- فهارس وتحسينات الأداء لجداول الدردشة\n\n-- ملاحظة: امتداد pg_trgm يجب تمكينه يدوياً من لوحة تحكم Supabase (Database → Extensions)\n\n-- أعمدة إضافية لدعم الردود والإشارة للرسائل\nALTER TABLE public.chat_messages\n  ADD COLUMN IF NOT EXISTS reply_to_message_id uuid,\n  ADD COLUMN IF NOT EXISTS reply_to_snippet text,\n  ADD COLUMN IF NOT EXISTS mentions jsonb",
      "-- فهارس chat_messages الأساسية\nCREATE INDEX IF NOT EXISTS chat_messages_conv_created_idx\n  ON public.chat_messages (conversation_id, created_at)",
      "CREATE INDEX IF NOT EXISTS chat_messages_created_idx\n  ON public.chat_messages (created_at)",
      "CREATE INDEX IF NOT EXISTS chat_messages_reply_to_idx\n  ON public.chat_messages (reply_to_message_id)",
      "-- فهرس trigram اختياري (يُنشأ فقط إذا كان امتداد pg_trgm متاحاً)\nDO $$\nBEGIN\n  IF EXISTS (SELECT 1 FROM pg_opclass WHERE opcname = 'gin_trgm_ops') THEN\n    IF NOT EXISTS (\n      SELECT 1 FROM pg_indexes\n      WHERE schemaname = 'public' AND indexname = 'chat_messages_body_trgm_idx'\n    ) THEN\n      EXECUTE $sql$\n        CREATE INDEX chat_messages_body_trgm_idx\n          ON public.chat_messages\n          USING gin ((coalesce(body, '')) gin_trgm_ops)\n      $sql$;\n    END IF;\n  ELSE\n    RAISE NOTICE 'skip chat_messages_body_trgm_idx: pg_trgm is not enabled';\n  END IF;\nEND;\n$$",
      "-- فهارس chat_participants\nCREATE INDEX IF NOT EXISTS chat_participants_conv_user_idx\n  ON public.chat_participants (conversation_id, user_uid)",
      "CREATE INDEX IF NOT EXISTS chat_participants_user_idx\n  ON public.chat_participants (user_uid)",
      "-- فهارس chat_reads\nCREATE INDEX IF NOT EXISTS chat_reads_conv_user_idx\n  ON public.chat_reads (conversation_id, user_uid)",
      "CREATE INDEX IF NOT EXISTS chat_reads_user_idx\n  ON public.chat_reads (user_uid)",
      "-- فهرس زمني للمحادثات\nCREATE INDEX IF NOT EXISTS chat_conversations_last_msg_at_idx\n  ON public.chat_conversations (last_msg_at)",
      "-- فهارس مرفقات الدردشة (إذا كان الجدول موجوداً)\nDO $$\nBEGIN\n  IF to_regclass('public.chat_attachments') IS NOT NULL THEN\n    CREATE INDEX IF NOT EXISTS chat_attachments_msg_idx\n      ON public.chat_attachments (message_id);\n    CREATE INDEX IF NOT EXISTS chat_attachments_bucket_path_idx\n      ON public.chat_attachments (bucket, path);\n  END IF;\nEND;\n$$"
    ],
    "name": "chat_indexes"
  },
  {
    "version": "20250919000000",
    "statements": [
      "DO $$\nBEGIN\n  IF EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'pg_trgm') THEN\n    RAISE NOTICE 'pg_trgm already enabled';\n  ELSE\n    RAISE NOTICE 'pg_trgm not enabled. Enable it manually from Supabase Dashboard → Database → Extensions.';\n  END IF;\nEND;\n$$"
    ],
    "name": "enable_pg_trgm"
  },
  {
    "version": "20250916",
    "statements": [
      "-- 20250916_chat_rls_cleanup.sql\r\n-- تنظيف السياسات القديمة/العامة والإبقاء على السياسات الجديدة الدقيقة.\r\n\r\n-- ───────── public.chat_messages ─────────\r\ndrop policy if exists chat_messages_insert on public.chat_messages",
      "drop policy if exists chat_messages_select on public.chat_messages",
      "drop policy if exists chat_messages_update on public.chat_messages",
      "drop policy if exists \"read messages where I'm participant\" on public.chat_messages",
      "drop policy if exists \"insert messages where I'm participant\" on public.chat_messages",
      "-- ───────── public.chat_conversations ─────────\r\ndrop policy if exists chat_conversations_insert on public.chat_conversations",
      "drop policy if exists chat_conversations_select on public.chat_conversations",
      "drop policy if exists chat_conversations_update on public.chat_conversations",
      "drop policy if exists \"select convs I'm in\" on public.chat_conversations",
      "-- ───────── public.chat_attachments ─────────\r\ndrop policy if exists chat_attachments_insert on public.chat_attachments",
      "drop policy if exists chat_attachments_select on public.chat_attachments",
      "-- ───────── storage.objects (bucket: chat-attachments) ─────────\r\n-- نحذف السياسات العامة كي لا تسمح برفع/قراءة خارج شرط المشاركة.\r\ndrop policy if exists \"read chat bucket\"   on storage.objects",
      "drop policy if exists \"upload chat bucket\" on storage.objects",
      "-- ملاحظة: نبقي سياساتنا الجديدة:\r\n--   storage.objects: chat_insert_if_participant, chat_delete_if_participant\r\n--   public.*       : msgs_*, conv_*, atts_*;"
    ],
    "name": "chat_rls_cleanup"
  },
  {
    "version": "2025091506",
    "statements": [
      "-- 2025091506_fix_chat_participants_policies.sql\r\n-- إصلاح سياسات chat_participants لمنع recursion\r\n\r\n-- تأكد أن RLS مفعّل\r\nALTER TABLE public.chat_participants ENABLE ROW LEVEL SECURITY",
      "-- احذف جميع السياسات الحالية على chat_participants (أياً كانت أسماؤها)\r\nDO $$\r\nDECLARE p text;\r\nBEGIN\r\n  FOR p IN\r\n    SELECT policyname\r\n    FROM pg_policies\r\n    WHERE schemaname = 'public' AND tablename = 'chat_participants'\r\n  LOOP\r\n    EXECUTE format('DROP POLICY IF EXISTS %I ON public.chat_participants', p);\r\n  END LOOP;\r\nEND$$",
      "-- ✅ SELECT: اسمح للمستخدم برؤية صفوفه فقط (أو السوبر أدمن)\r\nCREATE POLICY part_select_self_or_super\r\nON public.chat_participants\r\nFOR SELECT\r\nTO authenticated\r\nUSING ( user_uid = auth.uid() OR fn_is_super_admin() )",
      "-- ✅ INSERT: اسمح لمنشئ المحادثة بإضافة المشاركين (أو السوبر أدمن)\r\nCREATE POLICY part_insert_by_creator_or_super\r\nON public.chat_participants\r\nFOR INSERT\r\nTO authenticated\r\nWITH CHECK (\r\n  fn_is_super_admin()\r\n  OR EXISTS (\r\n      SELECT 1\r\n      FROM public.chat_conversations c\r\n      WHERE c.id = chat_participants.conversation_id\r\n        AND c.created_by = auth.uid()\r\n  )\r\n)",
      "-- (اختياري) UPDATE: عدّل صفك فقط (أو السوبر أدمن)\r\nCREATE POLICY part_update_self_or_super\r\nON public.chat_participants\r\nFOR UPDATE\r\nTO authenticated\r\nUSING ( user_uid = auth.uid() OR fn_is_super_admin() )\r\nWITH CHECK ( user_uid = auth.uid() OR fn_is_super_admin() )",
      "-- (اختياري) DELETE: اسمح لمنشئ المحادثة بحذف المشاركين (أو السوبر أدمن)\r\nCREATE POLICY part_delete_by_creator_or_super\r\nON public.chat_participants\r\nFOR DELETE\r\nTO authenticated\r\nUSING (\r\n  fn_is_super_admin()\r\n  OR EXISTS (\r\n      SELECT 1\r\n      FROM public.chat_conversations c\r\n      WHERE c.id = chat_participants.conversation_id\r\n        AND c.created_by = auth.uid()\r\n  )\r\n)"
    ],
    "name": "fix_chat_participants_policies"
  },
  {
    "version": "2025091505",
    "statements": [
      "-- إزالة الـ FKs المكرّرة التي تربك PostgREST عند الـ embed\r\ndo $$\r\nbegin\r\n  -- chat_participants → chat_conversations\r\n  if exists (select 1 from pg_constraint where conname = 'chat_participants_conversation_id_fkey')\r\n     and exists (select 1 from pg_constraint where conname = 'fk_chat_participants_conversation') then\r\n    alter table public.chat_participants\r\n      drop constraint fk_chat_participants_conversation;\r\n  end if;\r\n\r\n  -- احتياطًا: chat_messages → chat_conversations (إن كانت مكررة كذلك)\r\n  if exists (select 1 from pg_constraint where conname = 'chat_messages_conversation_id_fkey')\r\n     and exists (select 1 from pg_constraint where conname = 'fk_chat_messages_conversation') then\r\n    alter table public.chat_messages\r\n      drop constraint fk_chat_messages_conversation;\r\n  end if;\r\nend$$"
    ],
    "name": "drop_dup_fks"
  },
  {
    "version": "2025091504",
    "statements": [
      "alter table if exists chat_messages\r\n  add column if not exists account_id text,\r\n  add column if not exists device_id text,\r\n  add column if not exists local_id  bigint",
      "-- تقدر تضيف فهرس اختياريًا لتحسين الاستعلامات لو احتجت:\r\n-- create index if not exists chat_messages_idx_account on chat_messages(account_id);;"
    ],
    "name": "chat_triplet_patch"
  },
  {
    "version": "2025091503",
    "statements": [
      "do $$\r\nbegin\r\n  begin\r\n    alter publication supabase_realtime add table\r\n      chat_messages,\r\n      chat_conversations,\r\n      chat_participants,\r\n      chat_reads;\r\n  exception\r\n    when duplicate_object then\r\n      -- الجداول مضافة من قبل؛ تجاهل.\r\n      null;\r\n  end;\r\nend$$"
    ],
    "name": "publication_guard"
  },
  {
    "version": "2025091502",
    "statements": null,
    "name": "storage_policies_chat_attachments_fix"
  },
  {
    "version": "2025091501",
    "statements": [
      "-- 2025091501_storage_create_bucket.sql\r\n-- إنشاء bucket chat-attachments بطريقة متوافقة مع مختلف إصدارات Storage\r\n-- مع idempotency (لن يعيد الإنشاء إذا كان موجودًا).\r\n\r\nDO $$\r\nBEGIN\r\n  -- لو البكت موجود مسبقًا، لا تفعل شيئًا\r\n  IF EXISTS (SELECT 1 FROM storage.buckets WHERE id = 'chat-attachments') THEN\r\n    -- تأكد فقط أن الخاصية public = false\r\n    UPDATE storage.buckets SET public = false WHERE id = 'chat-attachments';\r\n    RETURN;\r\n  END IF;\r\n\r\n  -- جرّب التوقيع الشائع (اسم + عام/خاص)\r\n  BEGIN\r\n    PERFORM storage.create_bucket('chat-attachments', false);\r\n  EXCEPTION WHEN undefined_function THEN\r\n    -- إن لم تتوفر هذه الدالة بهذا التوقيع، جرّب توقيعًا أطول (نسخ أحدث)\r\n    BEGIN\r\n      -- بعض الإصدارات لديها وسيطات إضافية: (name, public, file_size_limit, allowed_mime_types, avif_autodetection)\r\n      PERFORM storage.create_bucket('chat-attachments', false, NULL, NULL, TRUE);\r\n    EXCEPTION WHEN undefined_function THEN\r\n      -- كحل أخير: أنشئ الصف مباشرة (مسموح في Supabase) واضبط public=false\r\n      INSERT INTO storage.buckets (id, name, public)\r\n      VALUES ('chat-attachments', 'chat-attachments', false);\r\n    END;\r\n  END;\r\nEND$$"
    ],
    "name": "storage_create_bucket"
  },
  {
    "version": "2025091500",
    "statements": [
      "-- 20250914_chat_add_triplet_and_account_id.sql\r\n-- إضافة أعمدة triplet إلى chat_messages + ضمان وجود account_id في chat_conversations\r\n-- وتهيئة مبدئية للقيم.\r\n\r\n-- ملاحظات:\r\n-- - نستخدم ALTER TABLE ... ADD COLUMN IF NOT EXISTS لضمان idempotency.\r\n-- - لا نضيف فهارس/قيود هنا (ستكون في ملف: 20250914_chat_indexes_and_fks.sql).\r\n-- - نوع account_id = UUID ليتماشى مع باقي الجداول (account_users/clinics).\r\n\r\n-- ╭──────────────────────────────────────────────────────────────────────────────╮\r\n-- │ 1) أعمدة جديدة                                                              │\r\n-- ╰──────────────────────────────────────────────────────────────────────────────╯\r\n\r\n-- في المحادثات: تأكد من وجود account_id\r\nALTER TABLE IF EXISTS public.chat_conversations\r\n  ADD COLUMN IF NOT EXISTS account_id uuid",
      "-- في الرسائل: أضف triplet (account_id/device_id/local_id)\r\nALTER TABLE IF EXISTS public.chat_messages\r\n  ADD COLUMN IF NOT EXISTS account_id uuid,\r\n  ADD COLUMN IF NOT EXISTS device_id  text,\r\n  ADD COLUMN IF NOT EXISTS local_id   bigint",
      "-- اختياري: تخزين device_id الأحدث للمستخدم على مستوى account_users (تستخدمه الخدمة)\r\nALTER TABLE IF EXISTS public.account_users\r\n  ADD COLUMN IF NOT EXISTS device_id text",
      "-- ╭──────────────────────────────────────────────────────────────────────────────╮\r\n-- │ 2) تهيئة مبدئية (Backfill)                                                 │\r\n-- ╰──────────────────────────────────────────────────────────────────────────────╯\r\n\r\n-- انسخ account_id من المحادثة إلى الرسالة حيثما كان مفقودًا.\r\n-- يفترض أن chat_conversations.account_id من النوع uuid.\r\nUPDATE public.chat_messages m\r\nSET account_id = c.account_id\r\nFROM public.chat_conversations c\r\nWHERE m.conversation_id = c.id\r\n  AND m.account_id IS NULL",
      "-- ╭──────────────────────────────────────────────────────────────────────────────╮\r\n-- │ 3) تعليقات توضيحية                                                         │\r\n-- ╰──────────────────────────────────────────────────────────────────────────────╯\r\n\r\nCOMMENT ON COLUMN public.chat_messages.account_id IS\r\n  'حقل اختياري لتجميع الرسائل حسب الحساب (clinic/account). يُستخدم ضمن triplet مع device_id/local_id.'",
      "COMMENT ON COLUMN public.chat_messages.device_id IS\r\n  'مُعرّف الجهاز/العميل المرسل (اختياري). جزء من triplet لمطابقة الرسائل محليًا.'",
      "COMMENT ON COLUMN public.chat_messages.local_id IS\r\n  'مُعرّف محلي متزايد (BIGINT) داخل الجهاز/الجلسة، يُستخدم لتجنّب التكرار أثناء الإرسال.'",
      "COMMENT ON COLUMN public.chat_conversations.account_id IS\r\n  'معرّف الحساب (clinic/account) المرتبطة به المحادثة.'",
      "-- انتهى;"
    ],
    "name": "chat_add_triplet_and_account_id"
  },
  {
    "version": "2025091407",
    "statements": null,
    "name": "storage_policies_chat"
  },
  {
    "version": "2025091406",
    "statements": [
      "do $$\r\ndeclare\r\n  pub_oid oid := (select oid from pg_publication where pubname = 'supabase_realtime');\r\nbegin\r\n  perform 1 from pg_publication_rel pr\r\n   join pg_class t on t.oid = pr.prrelid\r\n   where pr.prpubid = pub_oid and t.relname = 'chat_messages';\r\n  if not found then\r\n    execute 'alter publication supabase_realtime add table chat_messages';\r\n  end if;\r\n\r\n  perform 1 from pg_publication_rel pr\r\n   join pg_class t on t.oid = pr.prrelid\r\n   where pr.prpubid = pub_oid and t.relname = 'chat_conversations';\r\n  if not found then\r\n    execute 'alter publication supabase_realtime add table chat_conversations';\r\n  end if;\r\n\r\n  perform 1 from pg_publication_rel pr\r\n   join pg_class t on t.oid = pr.prrelid\r\n   where pr.prpubid = pub_oid and t.relname = 'chat_participants';\r\n  if not found then\r\n    execute 'alter publication supabase_realtime add table chat_participants';\r\n  end if;\r\n\r\n  perform 1 from pg_publication_rel pr\r\n   join pg_class t on t.oid = pr.prrelid\r\n   where pr.prpubid = pub_oid and t.relname = 'chat_reads';\r\n  if not found then\r\n    execute 'alter publication supabase_realtime add table chat_reads';\r\n  end if;\r\nend $$"
    ],
    "name": "publication_safe_add_chat"
  },
  {
    "version": "2025091405",
    "statements": [
      "-- 20250914_views_chat.sql\r\n-- عروض مساعدة لمنظومة الدردشة\r\n\r\nSET search_path TO public",
      "-- ───────────────────────── Drop existing (in dependency-safe order) ─────────────────────────\r\nDROP VIEW IF EXISTS public.v_chat_conversations_for_me",
      "DROP VIEW IF EXISTS public.v_chat_reads_for_me",
      "DROP VIEW IF EXISTS public.v_chat_last_message",
      "DROP VIEW IF EXISTS public.v_chat_messages_with_attachments",
      "-- ───────────────────────── View: v_chat_messages_with_attachments ─────────────────────────\r\n-- رسائل مع تجميع مرفقاتها في مصفوفة JSONB\r\nCREATE OR REPLACE VIEW public.v_chat_messages_with_attachments AS\r\nSELECT\r\n  m.id,\r\n  m.conversation_id,\r\n  m.sender_uid,\r\n  m.sender_email,\r\n  m.kind,\r\n  m.body,\r\n  m.created_at,\r\n  m.edited,\r\n  m.deleted,\r\n  m.edited_at,\r\n  m.deleted_at,\r\n  COALESCE(\r\n    jsonb_agg(\r\n      jsonb_build_object(\r\n        'id',       a.id,\r\n        'message_id', a.message_id,\r\n        'bucket',   a.bucket,\r\n        'path',     a.path,\r\n        'mime_type',a.mime_type,\r\n        'size_bytes', a.size_bytes,\r\n        'width',    a.width,\r\n        'height',   a.height,\r\n        'created_at', a.created_at\r\n      )\r\n    ) FILTER (WHERE a.id IS NOT NULL),\r\n    '[]'::jsonb\r\n  ) AS attachments\r\nFROM public.chat_messages m\r\nLEFT JOIN public.chat_attachments a\r\n  ON a.message_id = m.id\r\nGROUP BY\r\n  m.id, m.conversation_id, m.sender_uid, m.sender_email, m.kind, m.body,\r\n  m.created_at, m.edited, m.deleted, m.edited_at, m.deleted_at",
      "COMMENT ON VIEW public.v_chat_messages_with_attachments\r\nIS 'Chat messages with attachments aggregated as JSONB array.'",
      "-- ───────────────────────── View: v_chat_last_message ─────────────────────────\r\n-- آخر رسالة غير محذوفة لكل محادثة\r\nCREATE OR REPLACE VIEW public.v_chat_last_message AS\r\nSELECT\r\n  c.id AS conversation_id,\r\n  lm.id AS last_message_id,\r\n  lm.kind AS last_message_kind,\r\n  lm.body AS last_message_body,\r\n  lm.created_at AS last_message_created_at\r\nFROM public.chat_conversations c\r\nLEFT JOIN LATERAL (\r\n  SELECT m.id, m.kind, m.body, m.created_at\r\n  FROM public.chat_messages m\r\n  WHERE m.conversation_id = c.id\r\n    AND COALESCE(m.deleted, false) = false\r\n  ORDER BY m.created_at DESC\r\n  LIMIT 1\r\n) lm ON TRUE",
      "COMMENT ON VIEW public.v_chat_last_message\r\nIS 'Latest non-deleted message per conversation.'",
      "-- ───────────────────────── View: v_chat_reads_for_me ─────────────────────────\r\n-- آخر قراءة للمستخدم الحالي (حسب auth.uid())\r\nCREATE OR REPLACE VIEW public.v_chat_reads_for_me AS\r\nSELECT\r\n  r.conversation_id,\r\n  r.last_read_message_id,\r\n  r.last_read_at\r\nFROM public.chat_reads r\r\nWHERE r.user_uid = auth.uid()",
      "COMMENT ON VIEW public.v_chat_reads_for_me\r\nIS 'Per-conversation last read state for the current authenticated user (via auth.uid()).'",
      "-- ───────────────────────── View: v_chat_conversations_for_me ─────────────────────────\r\n-- محادثاتي (أنا عضوٌ فيها) + آخر رسالة + عدد غير المقروء + نص مختصر لآخر رسالة\r\nCREATE OR REPLACE VIEW public.v_chat_conversations_for_me AS\r\nWITH mine AS (\r\n  SELECT p.conversation_id\r\n  FROM public.chat_participants p\r\n  WHERE p.user_uid = auth.uid()\r\n),\r\nunread AS (\r\n  SELECT\r\n    c.id AS conversation_id,\r\n    -- آخر وقت قراءة لي (قد يكون null)\r\n    r.last_read_at,\r\n    -- عدد الرسائل غير المقروءة: الرسائل الأحدث من آخر قراءة وليست محذوفة\r\n    (\r\n      SELECT COUNT(1)\r\n      FROM public.chat_messages m\r\n      WHERE m.conversation_id = c.id\r\n        AND COALESCE(m.deleted, false) = false\r\n        AND (\r\n          r.last_read_at IS NULL\r\n          OR m.created_at > r.last_read_at\r\n        )\r\n    )::int AS unread_count\r\n  FROM public.chat_conversations c\r\n  LEFT JOIN public.v_chat_reads_for_me r\r\n    ON r.conversation_id = c.id\r\n)\r\nSELECT\r\n  c.id,\r\n  c.account_id,\r\n  c.is_group,\r\n  c.title,\r\n  c.created_by,\r\n  c.created_at,\r\n  c.updated_at,\r\n  c.last_msg_at,\r\n  c.last_msg_snippet,\r\n  -- مخرجات المساعدة:\r\n  lm.last_message_id,\r\n  lm.last_message_kind,\r\n  lm.last_message_body,\r\n  lm.last_message_created_at,\r\n  u.last_read_at,\r\n  u.unread_count,\r\n  -- نص مختصر مناسب للواجهة: صورة/نص مختصر 64 حرف\r\n  CASE\r\n    WHEN lm.last_message_kind = 'image' THEN '📷 صورة'\r\n    WHEN lm.last_message_body IS NULL OR btrim(lm.last_message_body) = '' THEN NULL\r\n    WHEN char_length(lm.last_message_body) > 64\r\n      THEN substr(lm.last_message_body, 1, 64) || '…'\r\n    ELSE lm.last_message_body\r\n  END AS last_message_text\r\nFROM public.chat_conversations c\r\nJOIN mine m\r\n  ON m.conversation_id = c.id\r\nLEFT JOIN public.v_chat_last_message lm\r\n  ON lm.conversation_id = c.id\r\nLEFT JOIN unread u\r\n  ON u.conversation_id = c.id",
      "COMMENT ON VIEW public.v_chat_conversations_for_me\r\nIS 'Conversations for current user (member via chat_participants + auth.uid()) with last message and unread counters.'",
      "-- ───────────────────────── Permissions ─────────────────────────\r\n-- المعرّفون فقط يمكنهم القراءة (RLS على الجداول الأساسية يقيّد النتائج).\r\nREVOKE ALL ON TABLE public.v_chat_messages_with_attachments FROM PUBLIC",
      "REVOKE ALL ON TABLE public.v_chat_last_message FROM PUBLIC",
      "REVOKE ALL ON TABLE public.v_chat_reads_for_me FROM PUBLIC",
      "REVOKE ALL ON TABLE public.v_chat_conversations_for_me FROM PUBLIC",
      "GRANT SELECT ON TABLE public.v_chat_messages_with_attachments TO authenticated",
      "GRANT SELECT ON TABLE public.v_chat_last_message TO authenticated",
      "GRANT SELECT ON TABLE public.v_chat_reads_for_me TO authenticated",
      "GRANT SELECT ON TABLE public.v_chat_conversations_for_me TO authenticated",
      "-- يمكنك السماح لـ service_role أيضًا عند الحاجة:\r\n-- GRANT SELECT ON TABLE public.v_chat_messages_with_attachments TO service_role;\r\n-- GRANT SELECT ON TABLE public.v_chat_last_message TO service_role;\r\n-- GRANT SELECT ON TABLE public.v_chat_reads_for_me TO service_role;\r\n-- GRANT SELECT ON TABLE public.v_chat_conversations_for_me TO service_role;;"
    ],
    "name": "views_chat"
  },
  {
    "version": "2025091404",
    "statements": [
      "-- 20250914_fn_sign_chat_attachment.sql\r\n-- وظيفة: توقيع رابط مرفق دردشة بعد التحقق من صلاحية المستخدم للوصول إليه.\r\n\r\nSET search_path TO public",
      "-- احذف الدالة إن وُجدت مسبقًا\r\nDROP FUNCTION IF EXISTS public.fn_sign_chat_attachment(text, text, integer)",
      "-- ملاحظة:\r\n-- تعتمد هذه الدالة على جداول:\r\n--   chat_attachments(message_id, bucket, path)\r\n--   chat_messages(id, conversation_id)\r\n--   chat_participants(conversation_id, user_uid)\r\n-- وتستخدم دالة Supabase Storage:\r\n--   storage.create_signed_url(bucket text, path text, expires_in int)\r\n-- إن كانت نسخة المنصة لا توفّر create_signed_url كدالة SQL، يمكنك الاعتماد\r\n-- على Edge Function بديل (chat/sign-attachment) كما هو مستخدم بالتطبيق.\r\n\r\nCREATE OR REPLACE FUNCTION public.fn_sign_chat_attachment(\r\n  p_bucket     text,\r\n  p_path       text,\r\n  p_expires_in integer DEFAULT 900  -- ثواني (15 دقيقة افتراضيًا)\r\n)\r\nRETURNS jsonb\r\nLANGUAGE plpgsql\r\nSECURITY DEFINER\r\nSET search_path = public\r\nAS $$\r\nDECLARE\r\n  v_message_id    uuid;\r\n  v_conversation  uuid;\r\n  v_has_access    boolean;\r\n  v_signed_url    text;\r\nBEGIN\r\n  -- تحقق أن هذا المسار مسجّل كمرفق دردشة\r\n  SELECT a.message_id\r\n    INTO v_message_id\r\n  FROM public.chat_attachments a\r\n  WHERE a.bucket = p_bucket\r\n    AND a.path   = p_path\r\n  LIMIT 1;\r\n\r\n  IF v_message_id IS NULL THEN\r\n    RAISE EXCEPTION 'Attachment not found' USING ERRCODE = 'no_data_found';\r\n  END IF;\r\n\r\n  -- اجلب محادثته\r\n  SELECT m.conversation_id\r\n    INTO v_conversation\r\n  FROM public.chat_messages m\r\n  WHERE m.id = v_message_id;\r\n\r\n  IF v_conversation IS NULL THEN\r\n    RAISE EXCEPTION 'Message not found for attachment' USING ERRCODE = 'no_data_found';\r\n  END IF;\r\n\r\n  -- تحقّق أن المستخدم الحالي عضو في المحادثة\r\n  SELECT EXISTS(\r\n    SELECT 1\r\n    FROM public.chat_participants p\r\n    WHERE p.conversation_id = v_conversation\r\n      AND p.user_uid = auth.uid()\r\n  ) INTO v_has_access;\r\n\r\n  IF NOT v_has_access THEN\r\n    RAISE EXCEPTION 'Forbidden' USING ERRCODE = 'insufficient_privilege';\r\n  END IF;\r\n\r\n  -- أنشئ الرابط الموقّع عبر دالة التخزين\r\n  -- ملاحظة: بعض منصّات Supabase توفّر storage.create_signed_url كدالة SQL.\r\n  -- إن لم تكن متاحة في بيئتك، استخدم Edge Function بديل.\r\n  BEGIN\r\n    v_signed_url := storage.create_signed_url(p_bucket, p_path, p_expires_in);\r\n  EXCEPTION WHEN undefined_function THEN\r\n    -- لو لم تتوفر الدالة في هذه البيئة، نرمي خطأ واضحًا.\r\n    RAISE EXCEPTION\r\n      'storage.create_signed_url is not available on this instance. Use the Edge Function instead.'\r\n      USING ERRCODE = 'feature_not_supported';\r\n  END;\r\n\r\n  RETURN jsonb_build_object(\r\n    'signedUrl', v_signed_url,\r\n    'url',       v_signed_url  -- للتوافق مع بعض العملاء\r\n  );\r\nEND;\r\n$$",
      "-- الأذونات: اسمح بالتنفيذ للمستخدمين الموثّقين وامنع المجهولين\r\nREVOKE ALL ON FUNCTION public.fn_sign_chat_attachment(text, text, integer) FROM PUBLIC",
      "GRANT EXECUTE ON FUNCTION public.fn_sign_chat_attachment(text, text, integer) TO authenticated",
      "-- بإمكانك منحها لـ service_role إن رغبت:\r\n-- GRANT EXECUTE ON FUNCTION public.fn_sign_chat_attachment(text, text, integer) TO service_role;\r\n\r\nCOMMENT ON FUNCTION public.fn_sign_chat_attachment(text, text, integer)\r\nIS 'Generates a signed URL for a chat attachment after verifying the caller is a participant in the conversation.'"
    ],
    "name": "fn_sign_chat_attachment"
  },
  {
    "version": "2025091403",
    "statements": [
      "-- 20250914_chat_triggers_last_msg.sql\r\n-- تحديث last_msg_at / last_msg_snippet تلقائياً بناءً على chat_messages.\r\n\r\nSET search_path TO public",
      "-- ╭──────────────────────────────────────────────────────────────────────────────╮\r\n-- │ 1) Helper: بناء مقتطف الرسالة داخل SQL                                      │\r\n-- ╰──────────────────────────────────────────────────────────────────────────────╯\r\n-- لا حاجة لدالة منفصلة للمقتطف؛ سنحسبه داخل دالة التحديث الرئيسية.\r\n\r\n-- ╭──────────────────────────────────────────────────────────────────────────────╮\r\n-- │ 2) Function: تحديث ملخص محادثة واحدة                                        │\r\n-- ╰──────────────────────────────────────────────────────────────────────────────╯\r\nCREATE OR REPLACE FUNCTION public.fn_chat_refresh_last_msg(p_conversation_id uuid)\r\nRETURNS void\r\nLANGUAGE plpgsql\r\nAS $$\r\nDECLARE\r\n  v_last_at    timestamptz;\r\n  v_last_kind  text;\r\n  v_last_body  text;\r\n  v_snippet    text;\r\nBEGIN\r\n  -- اجلب أحدث رسالة غير محذوفة\r\n  SELECT m.created_at, m.kind::text, m.body\r\n    INTO v_last_at, v_last_kind, v_last_body\r\n  FROM public.chat_messages m\r\n  WHERE m.conversation_id = p_conversation_id\r\n    AND COALESCE(m.deleted, false) = false\r\n  ORDER BY m.created_at DESC\r\n  LIMIT 1;\r\n\r\n  IF v_last_at IS NULL THEN\r\n    -- لا رسائل (أو كلها محذوفة)\r\n    UPDATE public.chat_conversations\r\n       SET last_msg_at = NULL,\r\n           last_msg_snippet = NULL\r\n     WHERE id = p_conversation_id;\r\n    RETURN;\r\n  END IF;\r\n\r\n  -- ابنِ الـ snippet\r\n  IF lower(coalesce(v_last_kind,'')) LIKE '%image%' OR lower(coalesce(v_last_kind,'')) = 'image' THEN\r\n    v_snippet := '📷 صورة';\r\n  ELSE\r\n    -- نص: تقليم للمسافات والأسطر ثم قص إلى 64 وإضافة \"…\"\r\n    v_last_body := btrim(coalesce(v_last_body, ''));\r\n    IF v_last_body = '' THEN\r\n      v_snippet := 'رسالة';\r\n    ELSE\r\n      IF length(v_last_body) > 64 THEN\r\n        v_snippet := substring(v_last_body from 1 for 64) || '…';\r\n      ELSE\r\n        v_snippet := v_last_body;\r\n      END IF;\r\n    END IF;\r\n  END IF;\r\n\r\n  -- حدّث المحادثة\r\n  UPDATE public.chat_conversations\r\n     SET last_msg_at      = v_last_at,\r\n         last_msg_snippet = v_snippet\r\n   WHERE id = p_conversation_id;\r\nEND;\r\n$$",
      "-- ╭──────────────────────────────────────────────────────────────────────────────╮\r\n-- │ 3) Trigger Function: استدعاء التحديث عند INSERT/UPDATE/DELETE               │\r\n-- ╰──────────────────────────────────────────────────────────────────────────────╯\r\nCREATE OR REPLACE FUNCTION public.fn_chat_messages_touch_last_msg()\r\nRETURNS trigger\r\nLANGUAGE plpgsql\r\nAS $$\r\nDECLARE\r\n  v_cid uuid;\r\nBEGIN\r\n  v_cid := COALESCE(NEW.conversation_id, OLD.conversation_id);\r\n  PERFORM public.fn_chat_refresh_last_msg(v_cid);\r\n  RETURN COALESCE(NEW, OLD);\r\nEND;\r\n$$",
      "-- ╭──────────────────────────────────────────────────────────────────────────────╮\r\n-- │ 4) Triggers على chat_messages                                               │\r\n-- ╰──────────────────────────────────────────────────────────────────────────────╯\r\n-- بعد الإدراج أو التعديل على الحقول المؤثرة (body/kind/deleted/created_at) نحدّث الملخّص.\r\nDROP TRIGGER IF EXISTS trg_chat_messages_last_msg_upd ON public.chat_messages",
      "CREATE TRIGGER trg_chat_messages_last_msg_upd\r\nAFTER INSERT OR UPDATE OF body, kind, deleted, created_at ON public.chat_messages\r\nFOR EACH ROW\r\nEXECUTE FUNCTION public.fn_chat_messages_touch_last_msg()",
      "-- في حال وُجد حذف فعلي (hard delete) لأي سبب، نحدّث الملخص أيضًا.\r\nDROP TRIGGER IF EXISTS trg_chat_messages_last_msg_del ON public.chat_messages",
      "CREATE TRIGGER trg_chat_messages_last_msg_del\r\nAFTER DELETE ON public.chat_messages\r\nFOR EACH ROW\r\nEXECUTE FUNCTION public.fn_chat_messages_touch_last_msg()",
      "-- انتهى;"
    ],
    "name": "chat_triggers_last_msg"
  },
  {
    "version": "2025091402",
    "statements": [
      "-- 2025091402_chat_policies.sql\r\n-- سياسات RLS + دوال مساعدة لازمة (idempotent) بدون استخدام NEW. داخل السياسات\r\n-- ومراعاة فروقات النوع uuid/text عبر التحويل إلى ::text\r\n\r\n-- ───────────────────────── Helper functions (idempotent) ─────────────────────────\r\n\r\n-- هل المستخدم الحالي سوبر أدمن؟\r\nCREATE OR REPLACE FUNCTION public.fn_is_super_admin()\r\nRETURNS boolean\r\nLANGUAGE sql\r\nSTABLE\r\nAS $$\r\n  SELECT EXISTS (\r\n           SELECT 1\r\n           FROM public.super_admins s\r\n           WHERE s.user_uid::text = auth.uid()::text\r\n         )\r\n      OR EXISTS (\r\n           SELECT 1\r\n           FROM public.account_users au\r\n           WHERE au.user_uid::text = auth.uid()::text\r\n             AND lower(au.role) = 'superadmin'\r\n         );\r\n$$",
      "-- آخر account_id للمستخدم الحالي (كنص)\r\nCREATE OR REPLACE FUNCTION public.fn_my_latest_account_id()\r\nRETURNS text\r\nLANGUAGE plpgsql\r\nSTABLE\r\nAS $$\r\nDECLARE\r\n  acc text;\r\nBEGIN\r\n  SELECT au.account_id::text\r\n    INTO acc\r\n  FROM public.account_users au\r\n  WHERE au.user_uid::text = auth.uid()::text\r\n  ORDER BY au.created_at DESC NULLS LAST\r\n  LIMIT 1;\r\n\r\n  RETURN acc;\r\nEND;\r\n$$",
      "-- ───────────────────────── Enable RLS (idempotent) ─────────────────────────\r\nALTER TABLE public.chat_conversations ENABLE ROW LEVEL SECURITY",
      "ALTER TABLE public.chat_participants  ENABLE ROW LEVEL SECURITY",
      "ALTER TABLE public.chat_messages      ENABLE ROW LEVEL SECURITY",
      "ALTER TABLE public.chat_reads         ENABLE ROW LEVEL SECURITY",
      "ALTER TABLE public.chat_attachments   ENABLE ROW LEVEL SECURITY",
      "-- ───────────────────────── chat_conversations ─────────────────────────\r\n\r\n-- SELECT: المشارك في المحادثة أو السوبر أدمن\r\nDO $$\r\nBEGIN\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE schemaname='public' AND tablename='chat_conversations'\r\n      AND policyname='conv_select_participant_or_super'\r\n  ) THEN\r\n    CREATE POLICY conv_select_participant_or_super\r\n    ON public.chat_conversations\r\n    FOR SELECT\r\n    TO authenticated\r\n    USING (\r\n      fn_is_super_admin() = true\r\n      OR EXISTS (\r\n        SELECT 1 FROM public.chat_participants p\r\n        WHERE p.conversation_id = chat_conversations.id\r\n          AND p.user_uid::text = auth.uid()::text\r\n      )\r\n    );\r\n  END IF;\r\nEND$$",
      "-- INSERT: المنشئ هو المستخدم الحالي + حارس account_id\r\nDO $$\r\nBEGIN\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE schemaname='public' AND tablename='chat_conversations'\r\n      AND policyname='conv_insert_creator_with_account_guard'\r\n  ) THEN\r\n    CREATE POLICY conv_insert_creator_with_account_guard\r\n    ON public.chat_conversations\r\n    FOR INSERT\r\n    TO authenticated\r\n    WITH CHECK (\r\n      created_by::text = auth.uid()::text\r\n      AND (\n        fn_is_super_admin() = true\n        OR account_id IS NULL\n        OR EXISTS (\n          SELECT 1\n          FROM public.account_users au\n          WHERE au.account_id = chat_conversations.account_id\n            AND au.user_uid::text = auth.uid()::text\n            AND coalesce(au.disabled, false) = false\n        )\n      )\n    );\r\n  END IF;\r\nEND$$",
      "-- UPDATE: صاحب الإنشاء أو السوبر + ثبات حارس الحساب\r\nDO $$\r\nBEGIN\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE schemaname='public' AND tablename='chat_conversations'\r\n      AND policyname='conv_update_creator_or_super'\r\n  ) THEN\r\n    CREATE POLICY conv_update_creator_or_super\r\n    ON public.chat_conversations\r\n    FOR UPDATE\r\n    TO authenticated\r\n    USING (\r\n      fn_is_super_admin() = true OR created_by::text = auth.uid()::text\r\n    )\r\n    WITH CHECK (\r\n      fn_is_super_admin() = true\n      OR account_id IS NULL\n      OR EXISTS (\n        SELECT 1\n        FROM public.account_users au\n        WHERE au.account_id = chat_conversations.account_id\n          AND au.user_uid::text = auth.uid()::text\n          AND coalesce(au.disabled, false) = false\n      )\n    );\r\n  END IF;\r\nEND$$",
      "-- ───────────────────────── chat_participants ─────────────────────────\r\n\r\n-- SELECT: أي مستخدم مشارك في نفس المحادثة أو سوبر\r\nDO $$\r\nBEGIN\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE schemaname='public' AND tablename='chat_participants'\r\n      AND policyname='parts_select_if_conversation_member_or_super'\r\n  ) THEN\r\n    CREATE POLICY parts_select_if_conversation_member_or_super\r\n    ON public.chat_participants\r\n    FOR SELECT\r\n    TO authenticated\r\n    USING (\r\n      fn_is_super_admin() = true\r\n      OR EXISTS (\r\n        SELECT 1 FROM public.chat_participants p2\r\n        WHERE p2.conversation_id = chat_participants.conversation_id\r\n          AND p2.user_uid::text = auth.uid()::text\r\n      )\r\n    );\r\n  END IF;\r\nEND$$",
      "-- INSERT: منشئ المحادثة أو السوبر فقط يضيف مشاركين\r\nDO $$\r\nBEGIN\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE schemaname='public' AND tablename='chat_participants'\r\n      AND policyname='parts_insert_by_conv_creator_or_super'\r\n  ) THEN\r\n    CREATE POLICY parts_insert_by_conv_creator_or_super\r\n    ON public.chat_participants\r\n    FOR INSERT\r\n    TO authenticated\r\n    WITH CHECK (\r\n      fn_is_super_admin() = true\r\n      OR EXISTS (\r\n        SELECT 1 FROM public.chat_conversations c\r\n        WHERE c.id = chat_participants.conversation_id\r\n          AND c.created_by::text = auth.uid()::text\r\n      )\r\n    );\r\n  END IF;\r\nEND$$",
      "-- UPDATE/DELETE: منشئ المحادثة أو السوبر\r\nDO $$\r\nBEGIN\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE schemaname='public' AND tablename='chat_participants'\r\n      AND policyname='parts_update_by_conv_creator_or_super'\r\n  ) THEN\r\n    CREATE POLICY parts_update_by_conv_creator_or_super\r\n    ON public.chat_participants\r\n    FOR UPDATE\r\n    TO authenticated\r\n    USING (\r\n      fn_is_super_admin() = true\r\n      OR EXISTS (\r\n        SELECT 1 FROM public.chat_conversations c\r\n        WHERE c.id = chat_participants.conversation_id\r\n          AND c.created_by::text = auth.uid()::text\r\n      )\r\n    )\r\n    WITH CHECK (\r\n      fn_is_super_admin() = true\r\n      OR EXISTS (\r\n        SELECT 1 FROM public.chat_conversations c\r\n        WHERE c.id = chat_participants.conversation_id\r\n          AND c.created_by::text = auth.uid()::text\r\n      )\r\n    );\r\n  END IF;\r\nEND$$",
      "DO $$\r\nBEGIN\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE schemaname='public' AND tablename='chat_participants'\r\n      AND policyname='parts_delete_by_conv_creator_or_super'\r\n  ) THEN\r\n    CREATE POLICY parts_delete_by_conv_creator_or_super\r\n    ON public.chat_participants\r\n    FOR DELETE\r\n    TO authenticated\r\n    USING (\r\n      fn_is_super_admin() = true\r\n      OR EXISTS (\r\n        SELECT 1 FROM public.chat_conversations c\r\n        WHERE c.id = chat_participants.conversation_id\r\n          AND c.created_by::text = auth.uid()::text\r\n      )\r\n    );\r\n  END IF;\r\nEND$$",
      "-- ───────────────────────── chat_messages ─────────────────────────\r\n\r\n-- SELECT: المشارك أو السوبر\r\nDO $$\r\nBEGIN\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE schemaname='public' AND tablename='chat_messages'\r\n      AND policyname='msgs_select_if_participant_or_super'\r\n  ) THEN\r\n    CREATE POLICY msgs_select_if_participant_or_super\r\n    ON public.chat_messages\r\n    FOR SELECT\r\n    TO authenticated\r\n    USING (\r\n      fn_is_super_admin() = true\r\n      OR EXISTS (\r\n        SELECT 1 FROM public.chat_participants p\r\n        WHERE p.conversation_id = chat_messages.conversation_id\r\n          AND p.user_uid::text = auth.uid()::text\r\n      )\r\n    );\r\n  END IF;\r\nEND$$",
      "-- INSERT: المرسل هو المستخدم الحالي + عضو بالمحادثة\r\nDO $$\r\nBEGIN\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE schemaname='public' AND tablename='chat_messages'\r\n      AND policyname='msgs_insert_sender_is_self_and_member'\r\n  ) THEN\r\n    CREATE POLICY msgs_insert_sender_is_self_and_member\r\n    ON public.chat_messages\r\n    FOR INSERT\r\n    TO authenticated\r\n    WITH CHECK (\r\n      sender_uid::text = auth.uid()::text\r\n      AND EXISTS (\r\n        SELECT 1 FROM public.chat_participants p\r\n        WHERE p.conversation_id = chat_messages.conversation_id\r\n          AND p.user_uid::text = auth.uid()::text\r\n      )\r\n    );\r\n  END IF;\r\nEND$$",
      "-- UPDATE/DELETE: صاحب الرسالة أو السوبر\r\nDO $$\r\nBEGIN\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE schemaname='public' AND tablename='chat_messages'\r\n      AND policyname='msgs_update_owner_or_super'\r\n  ) THEN\r\n    CREATE POLICY msgs_update_owner_or_super\r\n    ON public.chat_messages\r\n    FOR UPDATE\r\n    TO authenticated\r\n    USING (fn_is_super_admin() = true OR sender_uid::text = auth.uid()::text)\r\n    WITH CHECK (fn_is_super_admin() = true OR sender_uid::text = auth.uid()::text);\r\n  END IF;\r\nEND$$",
      "DO $$\r\nBEGIN\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE schemaname='public' AND tablename='chat_messages'\r\n      AND policyname='msgs_delete_owner_or_super'\r\n  ) THEN\r\n    CREATE POLICY msgs_delete_owner_or_super\r\n    ON public.chat_messages\r\n    FOR DELETE\r\n    TO authenticated\r\n    USING (fn_is_super_admin() = true OR sender_uid::text = auth.uid()::text);\r\n  END IF;\r\nEND$$",
      "-- ───────────────────────── chat_reads ─────────────────────────\r\n\r\n-- SELECT: صفوف قراءتي فقط وفي محادثات أنا عضو فيها (أو سوبر)\r\nDO $$\r\nBEGIN\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE schemaname='public' AND tablename='chat_reads'\r\n      AND policyname='reads_select_self_or_super_if_member'\r\n  ) THEN\r\n    CREATE POLICY reads_select_self_or_super_if_member\r\n    ON public.chat_reads\r\n    FOR SELECT\r\n    TO authenticated\r\n    USING (\r\n      fn_is_super_admin() = true\r\n      OR (\r\n        user_uid::text = auth.uid()::text\r\n        AND EXISTS (\r\n          SELECT 1 FROM public.chat_participants p\r\n          WHERE p.conversation_id = chat_reads.conversation_id\r\n            AND p.user_uid::text = auth.uid()::text\r\n        )\r\n      )\r\n    );\r\n  END IF;\r\nEND$$",
      "-- INSERT: أكتب فقط لقراءتي وفي محادثة أنا عضو فيها\r\nDO $$\r\nBEGIN\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE schemaname='public' AND tablename='chat_reads'\r\n      AND policyname='reads_insert_self_if_member'\r\n  ) THEN\r\n    CREATE POLICY reads_insert_self_if_member\r\n    ON public.chat_reads\r\n    FOR INSERT\r\n    TO authenticated\r\n    WITH CHECK (\r\n      user_uid::text = auth.uid()::text\r\n      AND EXISTS (\r\n        SELECT 1 FROM public.chat_participants p\r\n        WHERE p.conversation_id = chat_reads.conversation_id\r\n          AND p.user_uid::text = auth.uid()::text\r\n      )\r\n    );\r\n  END IF;\r\nEND$$",
      "-- UPDATE: أحدّث فقط صفّي وفي محادثة أنا عضو فيها (أو سوبر)\r\nDO $$\r\nBEGIN\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE schemaname='public' AND tablename='chat_reads'\r\n      AND policyname='reads_update_self_or_super_if_member'\r\n  ) THEN\r\n    CREATE POLICY reads_update_self_or_super_if_member\r\n    ON public.chat_reads\r\n    FOR UPDATE\r\n    TO authenticated\r\n    USING (\r\n      fn_is_super_admin() = true\r\n      OR (\r\n        user_uid::text = auth.uid()::text\r\n        AND EXISTS (\r\n          SELECT 1 FROM public.chat_participants p\r\n          WHERE p.conversation_id = chat_reads.conversation_id\r\n            AND p.user_uid::text = auth.uid()::text\r\n        )\r\n      )\r\n    )\r\n    WITH CHECK (\r\n      fn_is_super_admin() = true\r\n      OR (\r\n        user_uid::text = auth.uid()::text\r\n        AND EXISTS (\r\n          SELECT 1 FROM public.chat_participants p\r\n          WHERE p.conversation_id = chat_reads.conversation_id\r\n            AND p.user_uid::text = auth.uid()::text\r\n        )\r\n      )\r\n    );\r\n  END IF;\r\nEND$$",
      "-- ───────────────────────── chat_attachments (DB) ─────────────────────────\r\n\r\n-- SELECT: المشارك أو السوبر\r\nDO $$\r\nBEGIN\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE schemaname='public' AND tablename='chat_attachments'\r\n      AND policyname='atts_select_if_participant_or_super'\r\n  ) THEN\r\n    CREATE POLICY atts_select_if_participant_or_super\r\n    ON public.chat_attachments\r\n    FOR SELECT\r\n    TO authenticated\r\n    USING (\r\n      fn_is_super_admin() = true\r\n      OR EXISTS (\r\n        SELECT 1\r\n        FROM public.chat_messages m\r\n        JOIN public.chat_participants p\r\n          ON p.conversation_id = m.conversation_id\r\n        WHERE m.id = chat_attachments.message_id\r\n          AND p.user_uid::text = auth.uid()::text\r\n      )\r\n    );\r\n  END IF;\r\nEND$$",
      "-- INSERT: مشارك في المحادثة المرتبطة بالرسالة (أو سوبر)\r\nDO $$\r\nBEGIN\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE schemaname='public' AND tablename='chat_attachments'\r\n      AND policyname='atts_insert_if_participant_or_super'\r\n  ) THEN\r\n    CREATE POLICY atts_insert_if_participant_or_super\r\n    ON public.chat_attachments\r\n    FOR INSERT\r\n    TO authenticated\r\n    WITH CHECK (\r\n      fn_is_super_admin() = true\r\n      OR EXISTS (\r\n        SELECT 1\r\n        FROM public.chat_messages m\r\n        JOIN public.chat_participants p\r\n          ON p.conversation_id = m.conversation_id\r\n        WHERE m.id = chat_attachments.message_id\r\n          AND p.user_uid::text = auth.uid()::text\r\n      )\r\n    );\r\n  END IF;\r\nEND$$",
      "-- DELETE: صاحب الرسالة أو السوبر\r\nDO $$\r\nBEGIN\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM pg_policies\r\n    WHERE schemaname='public' AND tablename='chat_attachments'\r\n      AND policyname='atts_delete_owner_message_or_super'\r\n  ) THEN\r\n    CREATE POLICY atts_delete_owner_message_or_super\r\n    ON public.chat_attachments\r\n    FOR DELETE\r\n    TO authenticated\r\n    USING (\r\n      fn_is_super_admin() = true\r\n      OR EXISTS (\r\n        SELECT 1\r\n        FROM public.chat_messages m\r\n        WHERE m.id = chat_attachments.message_id\r\n          AND m.sender_uid::text = auth.uid()::text\r\n      )\r\n    );\r\n  END IF;\r\nEND$$"
    ],
    "name": "chat_policies"
  },
  {
    "version": "2025091401",
    "statements": [
      "-- 20250914_chat_indexes_and_fks.sql\r\n-- فهارس + علاقات (FK) لجدول الدردشة.\r\n-- ملاحظة مهمّة: أضفنا خطوة تنظيف قبل إضافة FK الخاص بـ chat_conversations.account_id → clinics.id\r\n-- لتفادي بيانات قديمة لا يقابلها صف في clinics.\r\n\r\n-- ───────────────────────────── فهارس عامة ─────────────────────────────\r\n\r\n-- رسائل المحادثات: تسلسل حسب الوقت داخل محادثة\r\nCREATE INDEX IF NOT EXISTS idx_chat_messages_conv_created_at\r\n  ON public.chat_messages (conversation_id, created_at)",
      "-- للمساعدة في الاستدعاءات اللحظية\r\nCREATE INDEX IF NOT EXISTS idx_chat_messages_conv_id\r\n  ON public.chat_messages (conversation_id, id)",
      "-- حقل النوع/الحذف للاستعلام عن آخر رسالة غير محذوفة\r\nCREATE INDEX IF NOT EXISTS idx_chat_messages_kind_deleted\r\n  ON public.chat_messages (kind, deleted)",
      "-- فهرس للمرسل (اختياري لكن مفيد)\r\nCREATE INDEX IF NOT EXISTS idx_chat_messages_sender\r\n  ON public.chat_messages (sender_uid)",
      "-- آخر نشاط للمحادثة\r\nCREATE INDEX IF NOT EXISTS idx_chat_conversations_last_msg_at\r\n  ON public.chat_conversations (last_msg_at DESC)",
      "-- ربط المشاركين بالمحادثة\r\nCREATE INDEX IF NOT EXISTS idx_chat_participants_conv_uid\r\n  ON public.chat_participants (conversation_id, user_uid)",
      "-- حالة القراءة لكل مستخدم داخل محادثة\r\nCREATE INDEX IF NOT EXISTS idx_chat_reads_conv_uid\r\n  ON public.chat_reads (conversation_id, user_uid)",
      "-- مرفقات الرسالة\r\nCREATE INDEX IF NOT EXISTS idx_chat_attachments_message\r\n  ON public.chat_attachments (message_id)",
      "-- حساب المحادثة (لجلب اسم العيادة مثلاً)\r\nCREATE INDEX IF NOT EXISTS idx_chat_conversations_account\r\n  ON public.chat_conversations (account_id)",
      "-- ───────────────────────────── علاقات (FK) مع حراسة ─────────────────────────────\r\n\r\n-- chat_attachments.message_id → chat_messages.id\r\nDO $$\r\nBEGIN\r\n  IF EXISTS (SELECT 1 FROM information_schema.tables\r\n             WHERE table_schema = 'public' AND table_name = 'chat_attachments')\r\n     AND NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname = 'fk_chat_attachments_message') THEN\r\n\r\n    IF EXISTS (SELECT 1 FROM information_schema.columns\r\n               WHERE table_schema='public' AND table_name='chat_attachments' AND column_name='message_id')\r\n       AND EXISTS (SELECT 1 FROM information_schema.tables\r\n                   WHERE table_schema='public' AND table_name='chat_messages') THEN\r\n\r\n      ALTER TABLE public.chat_attachments\r\n        ADD CONSTRAINT fk_chat_attachments_message\r\n        FOREIGN KEY (message_id)\r\n        REFERENCES public.chat_messages(id)\r\n        ON DELETE CASCADE;\r\n    END IF;\r\n  END IF;\r\nEND$$",
      "-- chat_messages.conversation_id → chat_conversations.id\r\nDO $$\r\nBEGIN\r\n  IF EXISTS (SELECT 1 FROM information_schema.tables\r\n             WHERE table_schema = 'public' AND table_name = 'chat_messages')\r\n     AND NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname = 'fk_chat_messages_conversation') THEN\r\n\r\n    IF EXISTS (SELECT 1 FROM information_schema.columns\r\n               WHERE table_schema='public' AND table_name='chat_messages' AND column_name='conversation_id')\r\n       AND EXISTS (SELECT 1 FROM information_schema.tables\r\n                   WHERE table_schema='public' AND table_name='chat_conversations') THEN\r\n\r\n      ALTER TABLE public.chat_messages\r\n        ADD CONSTRAINT fk_chat_messages_conversation\r\n        FOREIGN KEY (conversation_id)\r\n        REFERENCES public.chat_conversations(id)\r\n        ON DELETE CASCADE;\r\n    END IF;\r\n  END IF;\r\nEND$$",
      "-- chat_participants.conversation_id → chat_conversations.id\r\nDO $$\r\nBEGIN\r\n  IF EXISTS (SELECT 1 FROM information_schema.tables\r\n             WHERE table_schema = 'public' AND table_name = 'chat_participants')\r\n     AND NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname = 'fk_chat_participants_conversation') THEN\r\n\r\n    IF EXISTS (SELECT 1 FROM information_schema.columns\r\n               WHERE table_schema='public' AND table_name='chat_participants' AND column_name='conversation_id')\r\n       AND EXISTS (SELECT 1 FROM information_schema.tables\r\n                   WHERE table_schema='public' AND table_name='chat_conversations') THEN\r\n\r\n      ALTER TABLE public.chat_participants\r\n        ADD CONSTRAINT fk_chat_participants_conversation\r\n        FOREIGN KEY (conversation_id)\r\n        REFERENCES public.chat_conversations(id)\r\n        ON DELETE CASCADE;\r\n    END IF;\r\n  END IF;\r\nEND$$",
      "-- chat_reads.conversation_id → chat_conversations.id\r\nDO $$\r\nBEGIN\r\n  IF EXISTS (SELECT 1 FROM information_schema.tables\r\n             WHERE table_schema = 'public' AND table_name = 'chat_reads')\r\n     AND NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname = 'fk_chat_reads_conversation') THEN\r\n\r\n    IF EXISTS (SELECT 1 FROM information_schema.columns\r\n               WHERE table_schema='public' AND table_name='chat_reads' AND column_name='conversation_id')\r\n       AND EXISTS (SELECT 1 FROM information_schema.tables\r\n                   WHERE table_schema='public' AND table_name='chat_conversations') THEN\r\n\r\n      ALTER TABLE public.chat_reads\r\n        ADD CONSTRAINT fk_chat_reads_conversation\r\n        FOREIGN KEY (conversation_id)\r\n        REFERENCES public.chat_conversations(id)\r\n        ON DELETE CASCADE;\r\n    END IF;\r\n  END IF;\r\nEND$$",
      "-- chat_conversations.account_id → clinics.id (إن وجد جدول clinics)\r\n-- ⚠️ يتضمن تنظيف بيانات قديمة تحول دون إضافة القيد\r\nDO $$\r\nBEGIN\r\n  IF EXISTS (SELECT 1 FROM information_schema.tables\n             WHERE table_schema='public' AND table_name='accounts')\n     AND NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname='fk_chat_conversations_account') THEN\r\n\r\n    -- تأكد من وجود العمود أولًا\r\n    IF EXISTS (SELECT 1 FROM information_schema.columns\r\n               WHERE table_schema='public' AND table_name='chat_conversations' AND column_name='account_id') THEN\r\n\r\n      -- تنظيف: أي account_id لا يقابله صف في clinics → NULL لتفادي فشل إضافة الـ FK\r\n      UPDATE public.chat_conversations c\r\n      SET account_id = NULL\r\n      WHERE account_id IS NOT NULL\r\n        AND NOT EXISTS (\n          SELECT 1 FROM public.accounts x WHERE x.id = c.account_id\n        );\n\r\n      -- الآن أضِف الـ FK بأمان\r\n      ALTER TABLE public.chat_conversations\r\n        ADD CONSTRAINT fk_chat_conversations_account\r\n        FOREIGN KEY (account_id)\r\n        REFERENCES public.accounts(id)\n        ON DELETE SET NULL;\r\n    END IF;\r\n  END IF;\r\nEND$$"
    ],
    "name": "chat_indexes_and_fks"
  },
  {
    "version": "20250913040000",
    "statements": [
      "-- fix: ensure clean create by dropping old version (arg defaults cause 42P13)\r\nDO $$\r\nBEGIN\r\n  IF EXISTS (\r\n    SELECT 1\r\n    FROM pg_proc p\r\n    JOIN pg_namespace n ON n.oid = p.pronamespace\r\n    WHERE n.nspname = 'public'\r\n      AND p.proname = 'admin_create_employee_full'\r\n      AND p.proargtypes = ARRAY['uuid'::regtype,'text'::regtype,'text'::regtype]::oidvector\r\n  ) THEN\r\n    DROP FUNCTION public.admin_create_employee_full(uuid, text, text);\r\n  END IF;\r\nEND$$",
      "-- 20250913040000_restore_admin_bootstrap.sql\r\n-- Restores the SECURITY DEFINER helper used by admin flows and edge functions\r\n-- to bootstrap a clinic and attach the owner user.\r\n\r\nCREATE OR REPLACE FUNCTION public.admin_bootstrap_clinic_for_email(\r\n  clinic_name text,\r\n  owner_email text,\r\n  owner_role text\r\n)\r\nRETURNS uuid\r\nLANGUAGE plpgsql\r\nSECURITY DEFINER\r\nSET search_path = public, auth\r\nAS $$\r\nDECLARE\r\n  claims jsonb := coalesce(current_setting('request.jwt.claims', true)::jsonb, '{}'::jsonb);\r\n  caller_email text := lower(coalesce(claims->>'email', ''));\r\n  super_admin_email text := 'admin@elmam.com';\r\n  normalized_email text := lower(coalesce(trim(owner_email), ''));\r\n  normalized_role text := coalesce(nullif(trim(owner_role), ''), 'owner');\r\n  owner_uid uuid;\r\n  acc_id uuid;\r\nBEGIN\r\n  IF coalesce(trim(clinic_name), '') = '' THEN\r\n    RAISE EXCEPTION 'clinic_name is required';\r\n  END IF;\r\n\r\n  IF normalized_email = '' THEN\r\n    RAISE EXCEPTION 'owner_email is required';\r\n  END IF;\r\n\r\n  IF NOT (fn_is_super_admin() = true OR caller_email = super_admin_email) THEN\r\n    RAISE EXCEPTION 'forbidden' USING errcode = '42501';\r\n  END IF;\r\n\r\n  SELECT id\r\n    INTO owner_uid\r\n  FROM auth.users\r\n  WHERE lower(email) = normalized_email\r\n  ORDER BY created_at DESC\r\n  LIMIT 1;\r\n\r\n  IF owner_uid IS NULL THEN\r\n    RAISE EXCEPTION 'owner with email % not found in auth.users', normalized_email;\r\n  END IF;\r\n\r\n  INSERT INTO public.accounts(name, frozen)\r\n  VALUES (clinic_name, false)\r\n  RETURNING id INTO acc_id;\r\n\r\n  PERFORM public.admin_attach_employee(acc_id, owner_uid, normalized_role);\r\n\r\n  UPDATE public.account_users\r\n     SET email = normalized_email,\r\n         role = normalized_role,\r\n         updated_at = now()\r\n   WHERE account_id = acc_id\r\n     AND user_uid = owner_uid;\r\n\r\n  RETURN acc_id;\r\nEND;\r\n$$",
      "REVOKE ALL ON FUNCTION public.admin_bootstrap_clinic_for_email(text, text, text) FROM PUBLIC",
      "GRANT EXECUTE ON FUNCTION public.admin_bootstrap_clinic_for_email(text, text, text) TO authenticated",
      "GRANT EXECUTE ON FUNCTION public.admin_bootstrap_clinic_for_email(text, text, text) TO service_role",
      "CREATE OR REPLACE FUNCTION public.admin_create_employee_full(\r\n  p_account uuid,\r\n  p_email text,\r\n  p_password text\r\n)\r\nRETURNS jsonb\r\nLANGUAGE plpgsql\r\nSECURITY DEFINER\r\nSET search_path = public, auth\r\nAS $$\r\nDECLARE\r\n  v_is_super boolean := coalesce(fn_is_super_admin(), false)\r\n    OR lower(coalesce(auth.jwt()->>'role', '')) = 'superadmin'\r\n    OR lower(coalesce(auth.jwt()->>'email', '')) = 'admin@elmam.com';\r\n  v_account uuid := p_account;\r\n  v_email text := nullif(lower(trim(p_email)), '');\r\n  v_uid uuid;\r\nBEGIN\r\n  IF NOT v_is_super THEN\r\n    RAISE EXCEPTION 'forbidden' USING errcode = '42501';\r\n  END IF;\r\n\r\n  IF v_account IS NULL THEN\r\n    RAISE EXCEPTION 'account_id is required';\r\n  END IF;\r\n\r\n  IF v_email IS NULL THEN\r\n    RAISE EXCEPTION 'email is required';\r\n  END IF;\r\n\r\n  IF NOT EXISTS (SELECT 1 FROM public.accounts WHERE id = v_account) THEN\r\n    RAISE EXCEPTION 'account % not found', v_account;\r\n  END IF;\r\n\r\n  SELECT u.id\r\n    INTO v_uid\r\n  FROM auth.users u\r\n  WHERE lower(u.email) = v_email\r\n  ORDER BY u.created_at DESC\r\n  LIMIT 1;\r\n\r\n  IF v_uid IS NULL THEN\r\n    RAISE EXCEPTION 'user with email % not found in auth.users', v_email;\r\n  END IF;\r\n\r\n  PERFORM public.admin_attach_employee(v_account, v_uid, 'employee');\r\n\r\n  UPDATE public.account_users\r\n     SET email = v_email,\r\n         updated_at = now()\r\n   WHERE account_id = v_account\r\n     AND user_uid = v_uid;\r\n\r\n  RETURN jsonb_build_object(\r\n    'ok', true,\r\n    'account_id', v_account,\r\n    'user_uid', v_uid\r\n  );\r\nEND;\r\n$$",
      "REVOKE ALL ON FUNCTION public.admin_create_employee_full(uuid, text, text) FROM PUBLIC",
      "GRANT EXECUTE ON FUNCTION public.admin_create_employee_full(uuid, text, text) TO authenticated"
    ],
    "name": "restore_admin_bootstrap"
  },
  {
    "version": "20250913030000",
    "statements": [
      "-- 20250913030000_restore_clinics_view.sql\r\n-- Provides the clinics view consumed by admin inbox screens.\r\n\r\nCREATE OR REPLACE VIEW public.clinics AS\r\nSELECT\r\n  id,\r\n  name,\r\n  frozen,\r\n  created_at\r\nFROM public.accounts",
      "ALTER VIEW public.clinics SET (security_invoker = true)"
    ],
    "name": "restore_clinics_view"
  },
  {
    "version": "20250913020000",
    "statements": [
      "-- 20250913020000_restore_domain_policies.sql\r\n-- Reinstates row-level security for business tables using fn_is_account_member.\r\n\r\nCREATE OR REPLACE FUNCTION public.fn_is_account_member(p_account uuid)\r\nRETURNS boolean\r\nLANGUAGE sql\r\nSTABLE\r\nSECURITY DEFINER\r\nSET search_path = public\r\nAS $$\r\n  SELECT EXISTS (\r\n    SELECT 1\r\n    FROM public.account_users au\r\n    WHERE au.account_id = p_account\r\n      AND au.user_uid::text = auth.uid()::text\r\n      AND coalesce(au.disabled, false) = false\r\n  );\r\n$$",
      "REVOKE ALL ON FUNCTION public.fn_is_account_member(uuid) FROM PUBLIC",
      "GRANT EXECUTE ON FUNCTION public.fn_is_account_member(uuid) TO authenticated",
      "DO $$\r\nDECLARE\r\n  tbl text;\r\n  managed_tables constant text[] := ARRAY[\r\n    'patients','returns','consumptions','drugs','prescriptions','prescription_items',\r\n    'complaints','appointments','doctors','consumption_types','medical_services',\r\n    'service_doctor_share','employees','employees_loans','employees_salaries',\r\n    'employees_discounts','item_types','items','purchases','alert_settings',\r\n    'financial_logs','patient_services'\r\n  ];\r\nBEGIN\r\n  FOR tbl IN SELECT unnest(managed_tables) LOOP\r\n    EXECUTE format('ALTER TABLE public.%I ENABLE ROW LEVEL SECURITY', tbl);\r\n\r\n    EXECUTE format('DROP POLICY IF EXISTS %I_select_member_or_super ON public.%I', tbl, tbl);\r\n    EXECUTE format(\r\n      'CREATE POLICY %I_select_member_or_super ON public.%I FOR SELECT TO authenticated USING (fn_is_super_admin() = true OR fn_is_account_member(%I.account_id))',\r\n      tbl, tbl, tbl\r\n    );\r\n\r\n    EXECUTE format('DROP POLICY IF EXISTS %I_insert_member_or_super ON public.%I', tbl, tbl);\r\n    EXECUTE format(\r\n      'CREATE POLICY %I_insert_member_or_super ON public.%I FOR INSERT TO authenticated WITH CHECK (fn_is_super_admin() = true OR fn_is_account_member(%I.account_id))',\r\n      tbl, tbl, tbl\r\n    );\r\n\r\n    EXECUTE format('DROP POLICY IF EXISTS %I_update_member_or_super ON public.%I', tbl, tbl);\r\n    EXECUTE format(\r\n      'CREATE POLICY %I_update_member_or_super ON public.%I FOR UPDATE TO authenticated USING (fn_is_super_admin() = true OR fn_is_account_member(%I.account_id)) WITH CHECK (fn_is_super_admin() = true OR fn_is_account_member(%I.account_id))',\r\n      tbl, tbl, tbl, tbl\r\n    );\r\n\r\n    EXECUTE format('DROP POLICY IF EXISTS %I_delete_member_or_super ON public.%I', tbl, tbl);\r\n    EXECUTE format(\r\n      'CREATE POLICY %I_delete_member_or_super ON public.%I FOR DELETE TO authenticated USING (fn_is_super_admin() = true OR fn_is_account_member(%I.account_id))',\r\n      tbl, tbl, tbl\r\n    );\r\n  END LOOP;\r\nEND $$"
    ],
    "name": "restore_domain_policies"
  },
  {
    "version": "20250913010000",
    "statements": [
      "-- 20250913010000_restore_core_domain.sql\r\n-- Restores the business/chat schema expected by the Flutter application.\r\n-- All definitions mirror the archived schema that lib/ relies on, while using\r\n-- IF NOT EXISTS guards so we can apply safely onto existing environments.\r\n\r\nCREATE EXTENSION IF NOT EXISTS \"pgcrypto\"",
      "-- Super admins registry -------------------------------------------------------\r\nCREATE TABLE IF NOT EXISTS public.super_admins (\r\n  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),\r\n  created_at timestamptz NOT NULL DEFAULT now(),\r\n  account_id uuid,\r\n  device_id text,\r\n  local_id bigint,\r\n  email text UNIQUE,\r\n  user_uid uuid UNIQUE\r\n)",
      "-- Core business tables --------------------------------------------------------\r\nCREATE TABLE IF NOT EXISTS public.patients (\r\n  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),\r\n  account_id uuid NOT NULL REFERENCES public.accounts(id) ON DELETE CASCADE,\r\n  local_id bigint,\r\n  device_id text NOT NULL DEFAULT '',\r\n  name text,\r\n  age smallint,\r\n  diagnosis text,\r\n  phone_number text,\r\n  register_date date,\r\n  paid_amount numeric NOT NULL DEFAULT 0,\r\n  remaining numeric NOT NULL DEFAULT 0,\r\n  health_status text,\r\n  notes text,\r\n  preferences text,\r\n  doctor_id uuid,\r\n  doctor_name text,\r\n  doctor_specialization text,\r\n  service_type text,\r\n  service_id uuid,\r\n  service_name text,\r\n  service_cost numeric,\r\n  doctor_share numeric NOT NULL DEFAULT 0,\r\n  doctor_input numeric NOT NULL DEFAULT 0,\r\n  tower_share numeric NOT NULL DEFAULT 0,\r\n  department_share numeric NOT NULL DEFAULT 0,\r\n  doctor_review_pending boolean NOT NULL DEFAULT false,\r\n  doctor_reviewed_at timestamptz,\r\n  created_at timestamptz NOT NULL DEFAULT now(),\r\n  updated_at timestamptz NOT NULL DEFAULT now(),\r\n  is_deleted boolean NOT NULL DEFAULT false\r\n)",
      "CREATE TABLE IF NOT EXISTS public.returns (\r\n  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),\r\n  account_id uuid NOT NULL REFERENCES public.accounts(id) ON DELETE CASCADE,\r\n  local_id bigint,\r\n  date timestamptz,\r\n  patient_name text,\r\n  phone_number text,\r\n  diagnosis text,\r\n  remaining double precision,\r\n  age integer,\r\n  doctor text,\r\n  notes text,\r\n  device_id text NOT NULL DEFAULT '',\r\n  created_at timestamptz NOT NULL DEFAULT now(),\r\n  updated_at timestamptz NOT NULL DEFAULT now()\r\n)",
      "CREATE TABLE IF NOT EXISTS public.consumptions (\r\n  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),\r\n  account_id uuid NOT NULL REFERENCES public.accounts(id) ON DELETE CASCADE,\r\n  local_id bigint,\r\n  patient_id text,\r\n  item_id text,\r\n  quantity integer,\r\n  date timestamptz,\r\n  amount double precision,\r\n  note text,\r\n  device_id text NOT NULL DEFAULT '',\r\n  created_at timestamptz NOT NULL DEFAULT now(),\r\n  updated_at timestamptz NOT NULL DEFAULT now()\r\n)",
      "CREATE TABLE IF NOT EXISTS public.drugs (\r\n  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),\r\n  account_id uuid NOT NULL REFERENCES public.accounts(id) ON DELETE CASCADE,\r\n  local_id bigint,\r\n  name text NOT NULL,\r\n  notes text,\r\n  created_at timestamptz NOT NULL DEFAULT now(),\r\n  updated_at timestamptz NOT NULL DEFAULT now(),\r\n  device_id text NOT NULL DEFAULT ''\r\n)",
      "CREATE TABLE IF NOT EXISTS public.prescriptions (\r\n  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),\r\n  account_id uuid NOT NULL REFERENCES public.accounts(id) ON DELETE CASCADE,\r\n  local_id bigint,\r\n  patient_id uuid REFERENCES public.patients(id) ON DELETE CASCADE,\r\n  doctor_id uuid,\r\n  record_date timestamptz,\r\n  notes text,\r\n  created_at timestamptz NOT NULL DEFAULT now(),\r\n  updated_at timestamptz NOT NULL DEFAULT now(),\r\n  device_id text NOT NULL DEFAULT ''\r\n)",
      "CREATE TABLE IF NOT EXISTS public.prescription_items (\r\n  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),\r\n  account_id uuid NOT NULL REFERENCES public.accounts(id) ON DELETE CASCADE,\r\n  local_id bigint,\r\n  prescription_id uuid REFERENCES public.prescriptions(id) ON DELETE CASCADE,\r\n  drug_id uuid REFERENCES public.drugs(id) ON DELETE SET NULL,\r\n  days integer,\r\n  times_per_day integer,\r\n  notes text,\r\n  created_at timestamptz NOT NULL DEFAULT now(),\r\n  updated_at timestamptz NOT NULL DEFAULT now(),\r\n  device_id text NOT NULL DEFAULT ''\r\n)",
      "CREATE TABLE IF NOT EXISTS public.complaints (\r\n  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),\r\n  account_id uuid NOT NULL REFERENCES public.accounts(id) ON DELETE CASCADE,\r\n  local_id bigint,\r\n  title text,\r\n  description text,\r\n  status text,\r\n  created_at timestamptz NOT NULL DEFAULT now(),\r\n  updated_at timestamptz NOT NULL DEFAULT now(),\r\n  device_id text NOT NULL DEFAULT ''\r\n)",
      "CREATE TABLE IF NOT EXISTS public.appointments (\r\n  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),\r\n  account_id uuid NOT NULL REFERENCES public.accounts(id) ON DELETE CASCADE,\r\n  local_id bigint,\r\n  patient_id uuid REFERENCES public.patients(id) ON DELETE CASCADE,\r\n  doctor_id uuid,\r\n  appointment_time timestamptz,\r\n  status text,\r\n  notes text,\r\n  created_at timestamptz NOT NULL DEFAULT now(),\r\n  updated_at timestamptz NOT NULL DEFAULT now(),\r\n  device_id text NOT NULL DEFAULT ''\r\n)",
      "CREATE TABLE IF NOT EXISTS public.doctors (\r\n  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),\r\n  account_id uuid NOT NULL REFERENCES public.accounts(id) ON DELETE CASCADE,\r\n  local_id bigint,\r\n  employee_id uuid,\r\n  user_uid uuid,\r\n  name text,\r\n  specialization text,\r\n  phone_number text,\r\n  start_time timestamptz,\r\n  end_time timestamptz,\r\n  print_counter integer NOT NULL DEFAULT 0,\r\n  created_at timestamptz NOT NULL DEFAULT now(),\r\n  updated_at timestamptz NOT NULL DEFAULT now(),\r\n  device_id text NOT NULL DEFAULT ''\r\n)",
      "CREATE TABLE IF NOT EXISTS public.consumption_types (\r\n  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),\r\n  account_id uuid NOT NULL REFERENCES public.accounts(id) ON DELETE CASCADE,\r\n  local_id bigint,\r\n  type text,\r\n  created_at timestamptz NOT NULL DEFAULT now(),\r\n  updated_at timestamptz NOT NULL DEFAULT now(),\r\n  device_id text NOT NULL DEFAULT ''\r\n)",
      "CREATE TABLE IF NOT EXISTS public.medical_services (\r\n  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),\r\n  account_id uuid NOT NULL REFERENCES public.accounts(id) ON DELETE CASCADE,\r\n  local_id bigint,\r\n  name text,\r\n  cost numeric,\r\n  service_type text,\r\n  created_at timestamptz NOT NULL DEFAULT now(),\r\n  updated_at timestamptz NOT NULL DEFAULT now(),\r\n  device_id text NOT NULL DEFAULT ''\r\n)",
      "CREATE TABLE IF NOT EXISTS public.service_doctor_share (\r\n  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),\r\n  account_id uuid NOT NULL REFERENCES public.accounts(id) ON DELETE CASCADE,\r\n  local_id bigint,\r\n  service_id uuid REFERENCES public.medical_services(id) ON DELETE CASCADE,\r\n  doctor_id uuid REFERENCES public.doctors(id) ON DELETE CASCADE,\r\n  share_percentage numeric,\r\n  tower_share_percentage numeric,\r\n  is_hidden boolean NOT NULL DEFAULT false,\r\n  created_at timestamptz NOT NULL DEFAULT now(),\r\n  updated_at timestamptz NOT NULL DEFAULT now(),\r\n  device_id text NOT NULL DEFAULT ''\r\n)",
      "CREATE TABLE IF NOT EXISTS public.employees (\r\n  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),\r\n  account_id uuid NOT NULL REFERENCES public.accounts(id) ON DELETE CASCADE,\r\n  local_id bigint,\r\n  name text,\r\n  identity_number text,\r\n  phone_number text,\r\n  job_title text,\r\n  address text,\r\n  marital_status text,\r\n  basic_salary numeric,\r\n  final_salary numeric,\r\n  is_doctor boolean NOT NULL DEFAULT false,\r\n  user_uid uuid,\r\n  created_at timestamptz NOT NULL DEFAULT now(),\r\n  updated_at timestamptz NOT NULL DEFAULT now(),\r\n  device_id text NOT NULL DEFAULT ''\r\n)",
      "CREATE TABLE IF NOT EXISTS public.employees_loans (\r\n  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),\r\n  account_id uuid NOT NULL REFERENCES public.accounts(id) ON DELETE CASCADE,\r\n  local_id bigint,\r\n  employee_id uuid REFERENCES public.employees(id) ON DELETE CASCADE,\r\n  loan_date_time timestamptz,\r\n  final_salary numeric,\r\n  ratio_sum numeric,\r\n  loan_amount numeric,\r\n  leftover numeric,\r\n  created_at timestamptz NOT NULL DEFAULT now(),\r\n  updated_at timestamptz NOT NULL DEFAULT now(),\r\n  device_id text NOT NULL DEFAULT ''\r\n)",
      "CREATE TABLE IF NOT EXISTS public.employees_salaries (\r\n  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),\r\n  account_id uuid NOT NULL REFERENCES public.accounts(id) ON DELETE CASCADE,\r\n  local_id bigint,\r\n  employee_id uuid REFERENCES public.employees(id) ON DELETE CASCADE,\r\n  year integer,\r\n  month integer,\r\n  final_salary numeric,\r\n  ratio_sum numeric,\r\n  total_loans numeric,\r\n  net_pay numeric,\r\n  is_paid boolean NOT NULL DEFAULT false,\r\n  payment_date timestamptz,\r\n  created_at timestamptz NOT NULL DEFAULT now(),\r\n  updated_at timestamptz NOT NULL DEFAULT now(),\r\n  device_id text NOT NULL DEFAULT ''\r\n)",
      "CREATE TABLE IF NOT EXISTS public.employees_discounts (\r\n  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),\r\n  account_id uuid NOT NULL REFERENCES public.accounts(id) ON DELETE CASCADE,\r\n  local_id bigint,\r\n  employee_id uuid REFERENCES public.employees(id) ON DELETE CASCADE,\r\n  discount_date_time timestamptz,\r\n  amount numeric,\r\n  notes text,\r\n  created_at timestamptz NOT NULL DEFAULT now(),\r\n  updated_at timestamptz NOT NULL DEFAULT now(),\r\n  device_id text NOT NULL DEFAULT ''\r\n)",
      "CREATE TABLE IF NOT EXISTS public.item_types (\r\n  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),\r\n  account_id uuid NOT NULL REFERENCES public.accounts(id) ON DELETE CASCADE,\r\n  local_id bigint,\r\n  name text,\r\n  created_at timestamptz NOT NULL DEFAULT now(),\r\n  updated_at timestamptz NOT NULL DEFAULT now(),\r\n  device_id text NOT NULL DEFAULT ''\r\n)",
      "CREATE UNIQUE INDEX IF NOT EXISTS item_types_unique_name\r\n  ON public.item_types (account_id, lower(name))",
      "CREATE TABLE IF NOT EXISTS public.items (\r\n  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),\r\n  account_id uuid NOT NULL REFERENCES public.accounts(id) ON DELETE CASCADE,\r\n  local_id bigint,\r\n  type_id uuid REFERENCES public.item_types(id) ON DELETE SET NULL,\r\n  name text,\r\n  price numeric,\r\n  stock numeric,\r\n  created_at timestamptz NOT NULL DEFAULT now(),\r\n  updated_at timestamptz NOT NULL DEFAULT now(),\r\n  device_id text NOT NULL DEFAULT ''\r\n)",
      "CREATE UNIQUE INDEX IF NOT EXISTS items_unique_type_name\r\n  ON public.items (account_id, type_id, lower(name))",
      "CREATE TABLE IF NOT EXISTS public.purchases (\r\n  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),\r\n  account_id uuid NOT NULL REFERENCES public.accounts(id) ON DELETE CASCADE,\r\n  local_id bigint,\r\n  date timestamptz,\r\n  item_id uuid REFERENCES public.items(id) ON DELETE SET NULL,\r\n  quantity integer,\r\n  total double precision,\r\n  created_at timestamptz NOT NULL DEFAULT now(),\r\n  device_id text NOT NULL DEFAULT '',\r\n  updated_at timestamptz NOT NULL DEFAULT now()\r\n)",
      "CREATE TABLE IF NOT EXISTS public.alert_settings (\r\n  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),\r\n  account_id uuid NOT NULL REFERENCES public.accounts(id) ON DELETE CASCADE,\r\n  local_id bigint,\r\n  item_id uuid REFERENCES public.items(id) ON DELETE SET NULL,\r\n  item_uuid uuid REFERENCES public.items(id) ON DELETE SET NULL,\r\n  threshold double precision,\r\n  notify_time timestamptz,\r\n  created_at timestamptz NOT NULL DEFAULT now(),\r\n  device_id text NOT NULL DEFAULT '',\r\n  is_enabled boolean NOT NULL DEFAULT true,\r\n  last_triggered timestamptz,\r\n  updated_at timestamptz NOT NULL DEFAULT now()\r\n)",
      "CREATE TABLE IF NOT EXISTS public.financial_logs (\r\n  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),\r\n  account_id uuid NOT NULL REFERENCES public.accounts(id) ON DELETE CASCADE,\r\n  local_id bigint,\r\n  transaction_type text,\r\n  operation text,\r\n  amount double precision,\r\n  employee_id text,\r\n  description text,\r\n  modification_details text,\r\n  \"timestamp\" timestamptz,\r\n  device_id text NOT NULL DEFAULT '',\r\n  created_at timestamptz NOT NULL DEFAULT now(),\r\n  updated_at timestamptz NOT NULL DEFAULT now()\r\n)",
      "CREATE TABLE IF NOT EXISTS public.patient_services (\r\n  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),\r\n  account_id uuid NOT NULL REFERENCES public.accounts(id) ON DELETE CASCADE,\r\n  local_id bigint,\r\n  patient_id uuid REFERENCES public.patients(id) ON DELETE CASCADE,\r\n  service_id uuid REFERENCES public.medical_services(id) ON DELETE SET NULL,\r\n  service_name text,\r\n  service_cost numeric,\r\n  created_at timestamptz NOT NULL DEFAULT now(),\r\n  updated_at timestamptz NOT NULL DEFAULT now(),\r\n  device_id text NOT NULL DEFAULT ''\r\n)",
      "-- Chat tables -----------------------------------------------------------------\r\nCREATE TABLE IF NOT EXISTS public.chat_conversations (\r\n  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),\r\n  account_id uuid REFERENCES public.accounts(id) ON DELETE SET NULL,\r\n  title text,\r\n  is_group boolean NOT NULL DEFAULT false,\r\n  created_by uuid NOT NULL REFERENCES auth.users(id),\r\n  created_at timestamptz NOT NULL DEFAULT now(),\r\n  updated_at timestamptz NOT NULL DEFAULT now(),\r\n  last_msg_at timestamptz,\r\n  last_msg_snippet text,\r\n  deleted_at timestamptz,\r\n  is_deleted boolean NOT NULL DEFAULT false\r\n)",
      "CREATE TABLE IF NOT EXISTS public.chat_participants (\r\n  account_id uuid REFERENCES public.accounts(id) ON DELETE CASCADE,\r\n  conversation_id uuid NOT NULL REFERENCES public.chat_conversations(id) ON DELETE CASCADE,\r\n  user_uid uuid NOT NULL,\r\n  email text,\r\n  nickname text,\r\n  role text,\r\n  joined_at timestamptz,\r\n  muted boolean NOT NULL DEFAULT false,\r\n  PRIMARY KEY (conversation_id, user_uid),\r\n  FOREIGN KEY (account_id, user_uid)\r\n    REFERENCES public.account_users(account_id, user_uid)\r\n)",
      "CREATE TABLE IF NOT EXISTS public.chat_messages (\r\n  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),\r\n  account_id uuid REFERENCES public.accounts(id) ON DELETE CASCADE,\r\n  conversation_id uuid NOT NULL REFERENCES public.chat_conversations(id) ON DELETE CASCADE,\r\n  sender_uid uuid NOT NULL,\r\n  sender_email text,\r\n  kind text NOT NULL DEFAULT 'text',\r\n  body text,\r\n  text text,\r\n  attachments jsonb NOT NULL DEFAULT '[]'::jsonb,\r\n  mentions jsonb NOT NULL DEFAULT '[]'::jsonb,\r\n  reply_to_message_id uuid REFERENCES public.chat_messages(id) ON DELETE SET NULL,\r\n  reply_to_id text,\r\n  reply_to_snippet text,\r\n  patient_id uuid,\r\n  created_at timestamptz NOT NULL DEFAULT now(),\r\n  edited boolean NOT NULL DEFAULT false,\r\n  edited_at timestamptz,\r\n  deleted boolean NOT NULL DEFAULT false,\r\n  deleted_at timestamptz,\r\n  is_deleted boolean NOT NULL DEFAULT false,\r\n  device_id text,\r\n  local_id bigint,\r\n  FOREIGN KEY (account_id, sender_uid)\r\n    REFERENCES public.account_users(account_id, user_uid)\r\n)",
      "CREATE UNIQUE INDEX IF NOT EXISTS uq_chat_messages_device_local\r\n  ON public.chat_messages (account_id, device_id, local_id)\r\n  WHERE account_id IS NOT NULL AND device_id IS NOT NULL AND local_id IS NOT NULL",
      "CREATE TABLE IF NOT EXISTS public.chat_reads (\r\n  account_id uuid REFERENCES public.accounts(id) ON DELETE CASCADE,\r\n  conversation_id uuid NOT NULL REFERENCES public.chat_conversations(id) ON DELETE CASCADE,\r\n  user_uid uuid NOT NULL,\r\n  last_read_message_id uuid REFERENCES public.chat_messages(id) ON DELETE SET NULL,\r\n  last_read_at timestamptz,\r\n  PRIMARY KEY (conversation_id, user_uid),\r\n  FOREIGN KEY (account_id, user_uid)\r\n    REFERENCES public.account_users(account_id, user_uid)\r\n)",
      "CREATE TABLE IF NOT EXISTS public.chat_attachments (\r\n  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),\r\n  account_id uuid REFERENCES public.accounts(id) ON DELETE CASCADE,\r\n  message_id uuid NOT NULL REFERENCES public.chat_messages(id) ON DELETE CASCADE,\r\n  bucket text NOT NULL DEFAULT 'chat-attachments',\r\n  path text NOT NULL,\r\n  mime_type text,\r\n  size_bytes integer,\r\n  width integer,\r\n  height integer,\r\n  created_at timestamptz NOT NULL DEFAULT now(),\r\n  deleted_at timestamptz,\r\n  is_deleted boolean NOT NULL DEFAULT false,\r\n  device_id text,\r\n  local_id bigint,\r\n  FOREIGN KEY (message_id)\r\n    REFERENCES public.chat_messages(id) ON DELETE CASCADE\r\n)",
      "CREATE UNIQUE INDEX IF NOT EXISTS uq_chat_attachments_device_local\r\n  ON public.chat_attachments (account_id, device_id, local_id)\r\n  WHERE account_id IS NOT NULL AND device_id IS NOT NULL AND local_id IS NOT NULL",
      "CREATE TABLE IF NOT EXISTS public.chat_reactions (\r\n  account_id uuid REFERENCES public.accounts(id) ON DELETE CASCADE,\r\n  message_id uuid NOT NULL REFERENCES public.chat_messages(id) ON DELETE CASCADE,\r\n  user_uid uuid NOT NULL,\r\n  emoji text NOT NULL CHECK (char_length(emoji) BETWEEN 1 AND 16),\r\n  created_at timestamptz NOT NULL DEFAULT now(),\r\n  deleted_at timestamptz,\r\n  is_deleted boolean NOT NULL DEFAULT false,\r\n  device_id text,\r\n  local_id bigint,\r\n  PRIMARY KEY (message_id, user_uid, emoji),\r\n  FOREIGN KEY (account_id, user_uid)\r\n    REFERENCES public.account_users(account_id, user_uid)\r\n)",
      "CREATE UNIQUE INDEX IF NOT EXISTS uq_chat_reactions_device_local\r\n  ON public.chat_reactions (account_id, device_id, local_id, emoji)\r\n  WHERE account_id IS NOT NULL AND device_id IS NOT NULL AND local_id IS NOT NULL",
      "-- Supporting indexes on frequently queried columns ---------------------------\r\nCREATE UNIQUE INDEX IF NOT EXISTS uix_drugs_account_lower_name\r\n  ON public.drugs (account_id, lower(name))",
      "CREATE UNIQUE INDEX IF NOT EXISTS service_doctor_share_unique\r\n  ON public.service_doctor_share (account_id, service_id, doctor_id)",
      "-- Triplet indexes & account indexes for sync tables --------------------------\r\nDO $$\r\nDECLARE\r\n  tbl text;\r\nBEGIN\r\n  FOR tbl IN SELECT unnest(ARRAY[\r\n    'patients','returns','consumptions','drugs','prescriptions','prescription_items',\r\n    'complaints','appointments','doctors','consumption_types','medical_services',\r\n    'service_doctor_share','employees','employees_loans','employees_salaries',\r\n    'employees_discounts','item_types','items','purchases','alert_settings',\r\n    'financial_logs','patient_services','account_users','super_admins'\r\n  ]) LOOP\r\n    EXECUTE format('CREATE UNIQUE INDEX IF NOT EXISTS %I_account_device_local_idx ON public.%I (account_id, device_id, local_id)', tbl, tbl);\r\n    EXECUTE format('CREATE INDEX IF NOT EXISTS %I_account_idx ON public.%I (account_id)', tbl, tbl);\r\n  END LOOP;\r\nEND $$",
      "-- Updated_at maintenance triggers -------------------------------------------\r\nCREATE OR REPLACE FUNCTION public.tg_set_updated_at()\r\nRETURNS trigger\r\nLANGUAGE plpgsql\r\nAS $$\r\nBEGIN\r\n  NEW.updated_at = now();\r\n  RETURN NEW;\r\nEND;\r\n$$",
      "DO $$\r\nDECLARE\r\n  tbl text;\r\n  managed_tables constant text[] := ARRAY[\r\n    'account_users','account_feature_permissions','patients','returns','consumptions','drugs',\r\n    'prescriptions','prescription_items','complaints','appointments','doctors','consumption_types',\r\n    'medical_services','service_doctor_share','employees','employees_loans','employees_salaries',\r\n    'employees_discounts','item_types','items','purchases','alert_settings','financial_logs',\r\n    'patient_services'\r\n  ];\r\nBEGIN\r\n  FOR tbl IN SELECT unnest(managed_tables) LOOP\r\n    IF to_regclass('public.'||tbl) IS NULL THEN CONTINUE; END IF;EXECUTE format('DROP TRIGGER IF EXISTS %I_set_updated_at ON public.%I', tbl, tbl);\r\n    EXECUTE format('CREATE TRIGGER %I_set_updated_at BEFORE UPDATE ON public.%I FOR EACH ROW EXECUTE FUNCTION public.tg_set_updated_at()', tbl, tbl);\r\n  END LOOP;\r\nEND $$"
    ],
    "name": "restore_core_domain"
  },
  {
    "version": "20250913001000",
    "statements": [
      "-- placeholder for remote version 20250913001000"
    ],
    "name": "placeholder"
  },
  {
    "version": "20250913000500",
    "statements": [
      "-- placeholder for remote version 20250913000500"
    ],
    "name": "placeholder"
  },
  {
    "version": "20250913000000",
    "statements": [
      "-- placeholder for remote version 20250913000000"
    ],
    "name": "placeholder"
  },
  {
    "version": "20250912235900",
    "statements": [
      "create or replace function public.fn_is_super_admin()\r\nreturns boolean\r\nlanguage plpgsql\r\nstable\r\nsecurity definer\r\nset search_path = public, auth\r\nas $$\r\ndeclare\r\n  v_role text := current_setting('request.jwt.claim.role', true);\r\n  v_uid uuid := auth.uid();\r\n  v_email text := lower(coalesce(auth.email(), ''));\r\n  v_lookup_email text;\n  v_super_email constant text := 'admin@elmam.com';\nbegin\r\n  -- allow service_role and other elevated JWTs outright\r\n  if v_role = 'service_role' then\r\n    return true;\r\n  end if;\r\n\r\n  -- explicit super_admins mappings by uid\r\n  if v_uid is not null then\r\n    if exists (\r\n      select 1\r\n        from public.super_admins sa\r\n       where sa.user_uid = v_uid\r\n    ) then\r\n      return true;\r\n    end if;\r\n  end if;\r\n\r\n  -- explicit mappings by stored email\r\n  if v_email <> '' then\r\n    if exists (\r\n      select 1\r\n        from public.super_admins sa\r\n       where lower(sa.email) = v_email\r\n    ) then\r\n      return true;\r\n    end if;\r\n    if v_email = v_super_email then\r\n      return true;\r\n    end if;\r\n  end if;\r\n\r\n  -- fallback: fetch email from auth.users when JWT omitted it\r\n  if v_uid is not null then\r\n    select lower(u.email)\r\n      into v_lookup_email\r\n      from auth.users u\r\n     where u.id = v_uid\r\n     limit 1;\r\n\r\n    if v_lookup_email is not null then\r\n      if exists (\r\n        select 1\r\n          from public.super_admins sa\r\n         where lower(sa.email) = v_lookup_email\r\n      ) then\r\n        return true;\r\n      end if;\r\n      if v_lookup_email = v_super_email then\r\n        return true;\r\n      end if;\r\n    end if;\r\n  end if;\r\n\r\n  return false;\r\nend;\r\n$$",
      "revoke all on function public.fn_is_super_admin() from public",
      "grant execute on function public.fn_is_super_admin() to authenticated",
      "grant execute on function public.fn_is_super_admin() to service_role"
    ],
    "name": "fn_is_super_admin_stub"
  },
  {
    "version": "20250904",
    "statements": null,
    "name": "placeholder"
  },
  {
    "version": "20250901090700",
    "statements": [
      "-- 20250901090700_drop_my_feature_permissions_for_redefine.sql\n-- Drops the early stub so core_domain_schema can redefine it with a different signature.\n\nDROP FUNCTION IF EXISTS public.my_feature_permissions(uuid)"
    ],
    "name": "drop_my_feature_permissions_for_redefine"
  },
  {
    "version": "20250901090600",
    "statements": [
      "-- 20250901090600_drop_my_profile_for_redefine.sql\n-- Allows later migrations to redefine my_profile with a different OUT signature.\n\nDROP FUNCTION IF EXISTS public.my_profile()"
    ],
    "name": "drop_my_profile_for_redefine"
  },
  {
    "version": "20250901090400",
    "statements": [
      "--//C:\\Users\\zidan\\AndroidStudioProjects\\aelmamclinic\\supabase\\migrations\\20250901090400_rpc_delete_employee.sql\r\n-- حذف ربط موظف بالحساب (لا يحذف مستخدم auth).\r\n-- سماحية الاستدعاء: owner/admin على الحساب أو السوبر أدمن.\r\n\r\ndrop function if exists public.delete_employee(uuid, uuid)",
      "create or replace function public.delete_employee(\r\n  p_account uuid,\r\n  p_user_uid uuid\r\n)\r\nreturns void as $$\r\ndeclare\r\n  claims jsonb := coalesce(current_setting('request.jwt.claims', true)::jsonb, '{}'::jsonb);\r\n  caller_uid uuid := nullif(claims->>'sub','')::uuid;\r\n  can_manage boolean;\r\n  is_super_admin boolean := public.fn_is_super_admin();\r\nbegin\r\n  select exists (\r\n    select 1\r\n    from public.account_users\r\n    where account_id = p_account\r\n      and user_uid = caller_uid\r\n      and lower(coalesce(role,'')) in ('owner','admin','superadmin')\r\n      and coalesce(disabled,false) = false\r\n  ) into can_manage;\r\n\r\n  if not (can_manage or is_super_admin) then\r\n    raise exception 'forbidden' using errcode = '42501';\r\n  end if;\r\n\r\n  delete from public.account_users\r\n   where account_id = p_account\r\n     and user_uid = p_user_uid;\r\n\r\n  -- اختياري: وسم البروفايل كـ \"removed\" بدلاً من الحذف\r\n  update public.profiles\r\n     set role = 'removed'\r\n   where id = p_user_uid\r\n     and coalesce(account_id, p_account) = p_account;\r\nend;\r\n$$ language plpgsql\r\nsecurity definer\r\nset search_path = public, auth",
      "revoke all on function public.delete_employee(uuid, uuid) from public",
      "grant execute on function public.delete_employee(uuid, uuid) to authenticated"
    ],
    "name": "rpc_delete_employee"
  },
  {
    "version": "20250901090300",
    "statements": [
      "--//C:\\Users\\zidan\\AndroidStudioProjects\\aelmamclinic\\supabase\\migrations\\20250901090300_rpc_set_employee_disabled.sql\r\n\r\n-- تمكين/تعطيل موظف ضمن حساب معيّن.\r\n-- سماحية الاستدعاء: owner/admin على الحساب أو السوبر أدمن.\r\n\r\ndrop function if exists public.set_employee_disabled(uuid, uuid, boolean)",
      "create or replace function public.set_employee_disabled(\r\n  p_account uuid,\r\n  p_user_uid uuid,\r\n  p_disabled boolean\r\n)\r\nreturns void as $$\ndeclare\n  claims jsonb := coalesce(current_setting('request.jwt.claims', true)::jsonb, '{}'::jsonb);\n  caller_uid uuid := nullif(claims->>'sub','')::uuid;\n  can_manage boolean;\n  is_super_admin boolean := public.fn_is_super_admin();\n  target_role text;\nbegin\n  select exists (\n    select 1\n    from public.account_users\n    where account_id = p_account\r\n      and user_uid = caller_uid\r\n      and lower(coalesce(role,'')) in ('owner','admin','superadmin')\r\n      and coalesce(disabled,false) = false\r\n  ) into can_manage;\r\n\r\n  if not (can_manage or is_super_admin) then\r\n    raise exception 'forbidden' using errcode = '42501';\r\n  end if;\r\n\r\n  update public.account_users\r\n     set disabled = coalesce(p_disabled, false)\r\n   where account_id = p_account\r\n     and user_uid = p_user_uid;\r\n\r\n  select nullif(lower(coalesce(role, '')), '')\n    into target_role\n  from public.account_users\n  where account_id = p_account\n    and user_uid = p_user_uid\n  limit 1;\n\n  -- اختياري: عكس الحالة على profiles (لو موجود)\n  update public.profiles\n     set role = case\n                  when p_disabled then 'disabled'\n                  else coalesce(target_role, 'employee')\n                end,\n         account_id = coalesce(account_id, p_account)\n   where id = p_user_uid;\nend;\n$$ language plpgsql\nsecurity definer\nset search_path = public, auth",
      "revoke all on function public.set_employee_disabled(uuid, uuid, boolean) from public",
      "grant execute on function public.set_employee_disabled(uuid, uuid, boolean) to authenticated"
    ],
    "name": "rpc_set_employee_disabled"
  },
  {
    "version": "20250901090200",
    "statements": [
      "--//C:\\Users\\zidan\\AndroidStudioProjects\\aelmamclinic\\supabase\\migrations\\20250901090200_rpc_list_employees_with_email.sql\r\n-- تُرجع موظفي الحساب مع البريد الإلكتروني (تعتمد على auth.users + account_users)\r\n-- سماحية الاستدعاء: owner/admin على نفس الحساب، أو السوبر أدمن بالبريد المحدد.\r\n\r\ndrop function if exists public.list_employees_with_email(uuid)",
      "create or replace function public.list_employees_with_email(p_account uuid)\r\nreturns table(\r\n  user_uid uuid,\r\n  email text,\r\n  role text,\r\n  disabled boolean,\r\n  created_at timestamptz\r\n) as $$\r\ndeclare\r\n  claims jsonb := coalesce(current_setting('request.jwt.claims', true)::jsonb, '{}'::jsonb);\r\n  caller_uid uuid := nullif(claims->>'sub','')::uuid;\r\n  caller_email text := lower(coalesce(claims->>'email',''));\r\n  super_admin_email text := 'admin@elmam.com';\n  can_manage boolean;\r\nbegin\r\n  -- تحقق الصلاحيات: (owner/admin) على الحساب أو سوبر أدمن بالبريد\r\n  select exists (\r\n    select 1\r\n    from public.account_users\r\n    where account_id = p_account\r\n      and user_uid = caller_uid\r\n      and role in ('owner','admin')\r\n      and coalesce(disabled,false) = false\r\n  ) into can_manage;\r\n\r\n  if not (can_manage or caller_email = lower(super_admin_email)) then\r\n    raise exception 'forbidden' using errcode = '42501';\r\n  end if;\r\n\r\n  return query\r\n  select\r\n    au.user_uid,\r\n    u.email,\r\n    au.role,\r\n    coalesce(au.disabled,false) as disabled,\r\n    au.created_at\r\n  from public.account_users au\r\n  left join auth.users u on u.id = au.user_uid\r\n  where au.account_id = p_account\r\n  order by au.created_at desc;\r\nend;\r\n$$ language plpgsql\r\nsecurity definer\r\nset search_path = public, auth",
      "revoke all on function public.list_employees_with_email(uuid) from public",
      "grant execute on function public.list_employees_with_email(uuid) to authenticated"
    ],
    "name": "rpc_list_employees_with_email"
  },
  {
    "version": "20250901090100",
    "statements": [
      "--//C:\\Users\\zidan\\AndroidStudioProjects\\aelmamclinic\\supabase\\migrations\\20250901090100_rpc_my_account_id_and_my_accounts.sql\r\n-- my_account_id() و my_accounts()\r\n-- يوفّر account_id الافتراضي و/أو كل الحسابات المرتبطة بالمستخدم الحالي.\r\n\r\ncreate or replace function public.my_account_id()\r\nreturns uuid\r\nlanguage sql\r\nsecurity definer\r\nset search_path = public\r\nas $$\r\n  select account_id\r\n  from public.account_users\r\n  where user_uid = auth.uid()\r\n    and coalesce(disabled, false) = false\r\n  order by created_at desc\r\n  limit 1;\r\n$$",
      "revoke all on function public.my_account_id() from public",
      "grant execute on function public.my_account_id() to authenticated",
      "create or replace function public.my_accounts()\r\nreturns setof uuid\r\nlanguage sql\r\nsecurity definer\r\nset search_path = public\r\nas $$\r\n  select account_id\r\n  from public.account_users\r\n  where user_uid = auth.uid()\r\n    and coalesce(disabled, false) = false\r\n  order by created_at desc;\r\n$$",
      "revoke all on function public.my_accounts() from public",
      "grant execute on function public.my_accounts() to authenticated",
      "create or replace function public.my_profile()\r\nreturns table (\r\n  id uuid,\r\n  email text,\r\n  role text,\r\n  account_id uuid,\r\n  display_name text,\r\n  account_ids uuid[]\r\n)\r\nlanguage sql\r\nsecurity definer\r\nset search_path = public, auth\r\nas $$\r\n  with me as (\r\n    select\r\n      u.id,\r\n      u.email,\r\n      p.role as profile_role,\r\n      p.account_id as profile_account_id,\r\n      p.display_name,\r\n      (\r\n        select array_agg(au.account_id order by au.created_at desc)\r\n        from public.account_users au\r\n        where au.user_uid = u.id\r\n          and coalesce(au.disabled, false) = false\r\n      ) as membership_accounts,\r\n      (\r\n        select au.role\r\n        from public.account_users au\r\n        where au.user_uid = u.id\r\n          and coalesce(au.disabled, false) = false\r\n        order by au.created_at desc\r\n        limit 1\r\n      ) as membership_role\r\n    from auth.users u\r\n    left join public.profiles p on p.id = u.id\r\n    where u.id = auth.uid()\r\n  )\r\n  select\r\n    me.id,\r\n    me.email,\r\n    coalesce(me.profile_role, me.membership_role, 'employee') as role,\r\n    coalesce(me.profile_account_id, me.membership_accounts[1], public.my_account_id()) as account_id,\r\n    me.display_name,\r\n    coalesce(me.membership_accounts, array[]::uuid[]) as account_ids\r\n  from me;\r\n$$",
      "revoke all on function public.my_profile() from public",
      "grant execute on function public.my_profile() to authenticated",
      "create or replace function public.my_feature_permissions(p_account uuid)\r\nreturns table (\r\n  account_id uuid,\r\n  allowed_features text[],\r\n  can_create boolean,\r\n  can_update boolean,\r\n  can_delete boolean\r\n)\r\nlanguage plpgsql\r\nsecurity definer\r\nset search_path = public, auth\r\nas $$\r\ndeclare\r\n  v_uid uuid := auth.uid();\r\n  v_is_super boolean := coalesce(fn_is_super_admin(), false)\r\n    or lower(coalesce(auth.jwt()->>'role', '')) = 'superadmin'\r\n    or lower(coalesce(auth.jwt()->>'email', '')) = 'admin@elmam.com';\r\n  v_allowed text[];\r\n  v_can_create boolean;\r\n  v_can_update boolean;\r\n  v_can_delete boolean;\r\nbegin\r\n  if v_uid is null then\r\n    return;\r\n  end if;\r\n\r\n  if p_account is null then\r\n    return query select null::uuid, array[]::text[], true, true, true;\r\n  end if;\r\n\r\n  if not v_is_super then\r\n    if not exists (\r\n      select 1\r\n      from public.account_users au\r\n      where au.account_id = p_account\r\n        and au.user_uid = v_uid\r\n        and coalesce(au.disabled, false) = false\r\n    ) then\r\n      raise exception 'forbidden' using errcode = '42501';\r\n    end if;\r\n  end if;\r\n\r\n  if not exists (\r\n    select 1\r\n    from information_schema.tables\r\n    where table_schema = 'public' and table_name = 'account_feature_permissions'\r\n  ) then\r\n    return query select p_account, array[]::text[], true, true, true;\r\n  end if;\r\n\r\n  select\r\n    afp.allowed_features,\r\n    afp.can_create,\r\n    afp.can_update,\r\n    afp.can_delete\r\n  into v_allowed, v_can_create, v_can_update, v_can_delete\r\n  from public.account_feature_permissions afp\r\n  where afp.account_id = p_account\r\n    and (afp.user_uid = v_uid or afp.user_uid is null)\r\n  order by case when afp.user_uid = v_uid then 0 else 1 end\r\n  limit 1;\r\n\r\n  return query select\r\n    p_account,\r\n    coalesce(v_allowed, array[]::text[]),\r\n    coalesce(v_can_create, true),\r\n    coalesce(v_can_update, true),\r\n    coalesce(v_can_delete, true);\r\nend;\r\n$$",
      "revoke all on function public.my_feature_permissions(uuid) from public",
      "grant execute on function public.my_feature_permissions(uuid) to authenticated",
      "create or replace function public.admin_create_owner_full(\r\n  p_clinic_name text,\r\n  p_owner_email text,\r\n  p_owner_password text\r\n)\r\nreturns jsonb\r\nlanguage plpgsql\r\nsecurity definer\r\nset search_path = public, auth\r\nas $$\r\ndeclare\r\n  v_is_super boolean := coalesce(fn_is_super_admin(), false)\r\n    or lower(coalesce(auth.jwt()->>'role', '')) = 'superadmin'\r\n    or lower(coalesce(auth.jwt()->>'email', '')) = 'admin@elmam.com';\r\n  v_owner_uid uuid;\r\n  v_account uuid;\r\nbegin\r\n  if not v_is_super then\r\n    raise exception 'forbidden' using errcode = '42501';\r\n  end if;\r\n\r\n  if p_clinic_name is null or length(trim(p_clinic_name)) = 0 then\r\n    raise exception 'clinic_name is required';\r\n  end if;\r\n\r\n  if p_owner_email is null or length(trim(p_owner_email)) = 0 then\r\n    raise exception 'owner_email is required';\r\n  end if;\r\n\r\n  select u.id\r\n    into v_owner_uid\r\n  from auth.users u\r\n  where lower(u.email) = lower(p_owner_email)\r\n  order by u.created_at desc\r\n  limit 1;\r\n\r\n  if v_owner_uid is null then\r\n    raise exception 'owner with email % not found in auth.users', p_owner_email;\r\n  end if;\r\n\r\n  v_account := public.admin_bootstrap_clinic_for_email(p_clinic_name, p_owner_email, 'owner');\r\n\r\n  return jsonb_build_object(\r\n    'ok', true,\r\n    'account_id', v_account,\r\n    'owner_uid', v_owner_uid\r\n  );\r\nend;\r\n$$",
      "revoke all on function public.admin_create_owner_full(text, text, text) from public",
      "grant execute on function public.admin_create_owner_full(text, text, text) to authenticated",
      "create or replace function public.admin_create_employee_full(\r\n  p_account uuid,\r\n  p_email text,\r\n  p_password text\r\n)\r\nreturns jsonb\r\nlanguage plpgsql\r\nsecurity definer\r\nset search_path = public, auth\r\nas $$\r\ndeclare\r\n  v_is_super boolean := coalesce(fn_is_super_admin(), false)\r\n    or lower(coalesce(auth.jwt()->>'role', '')) = 'superadmin'\r\n    or lower(coalesce(auth.jwt()->>'email', '')) = 'admin@elmam.com';\r\n  v_uid uuid;\r\nbegin\r\n  if not v_is_super then\r\n    raise exception 'forbidden' using errcode = '42501';\r\n  end if;\r\n\r\n  if p_account is null then\r\n    raise exception 'account_id is required';\r\n  end if;\r\n\r\n  if p_email is null or length(trim(p_email)) = 0 then\r\n    raise exception 'email is required';\r\n  end if;\r\n\r\n  if not exists (select 1 from public.accounts a where a.id = p_account) then\r\n    raise exception 'account % not found', p_account;\r\n  end if;\r\n\r\n  select u.id\r\n    into v_uid\r\n  from auth.users u\r\n  where lower(u.email) = lower(p_email)\r\n  order by u.created_at desc\r\n  limit 1;\r\n\r\n  if v_uid is null then\r\n    raise exception 'user with email % not found in auth.users', p_email;\r\n  end if;\r\n\r\n  perform public.admin_attach_employee(p_account, v_uid, 'employee');\r\n\r\n  return jsonb_build_object(\r\n    'ok', true,\r\n    'account_id', p_account,\r\n    'user_uid', v_uid\r\n  );\r\nend;\r\n$$",
      "revoke all on function public.admin_create_employee_full(uuid, text, text) from public",
      "grant execute on function public.admin_create_employee_full(uuid, text, text) to authenticated",
      "create or replace function public.admin_list_clinics()\r\nreturns table (\r\n  id uuid,\r\n  name text,\r\n  frozen boolean,\r\n  created_at timestamptz\r\n)\r\nlanguage plpgsql\r\nsecurity definer\r\nset search_path = public, auth\r\nas $$\r\ndeclare\r\n  v_is_super boolean := coalesce(fn_is_super_admin(), false)\r\n    or lower(coalesce(auth.jwt()->>'role', '')) = 'superadmin'\r\n    or lower(coalesce(auth.jwt()->>'email', '')) = 'admin@elmam.com';\r\nbegin\r\n  if not v_is_super then\r\n    raise exception 'forbidden' using errcode = '42501';\r\n  end if;\r\n\r\n  return query\r\n  select\r\n    a.id,\r\n    a.name,\r\n    coalesce(a.frozen, false) as frozen,\r\n    a.created_at\r\n  from public.accounts a\r\n  order by a.created_at desc;\r\nend;\r\n$$",
      "revoke all on function public.admin_list_clinics() from public",
      "grant execute on function public.admin_list_clinics() to authenticated",
      "create or replace function public.admin_set_clinic_frozen(\r\n  p_account_id uuid,\r\n  p_frozen boolean\r\n)\r\nreturns void\r\nlanguage plpgsql\r\nsecurity definer\r\nset search_path = public, auth\r\nas $$\r\ndeclare\r\n  v_is_super boolean := coalesce(fn_is_super_admin(), false)\r\n    or lower(coalesce(auth.jwt()->>'role', '')) = 'superadmin'\r\n    or lower(coalesce(auth.jwt()->>'email', '')) = 'admin@elmam.com';\r\nbegin\r\n  if p_account_id is null then\r\n    raise exception 'account_id is required';\r\n  end if;\r\n\r\n  if not v_is_super then\r\n    if not exists (\r\n      select 1\r\n      from public.account_users au\r\n      where au.account_id = p_account_id\r\n        and au.user_uid = auth.uid()\r\n        and coalesce(au.disabled, false) = false\r\n        and lower(coalesce(au.role, '')) in ('owner', 'admin', 'superadmin')\r\n    ) then\r\n      raise exception 'forbidden' using errcode = '42501';\r\n    end if;\r\n  end if;\r\n\r\n  update public.accounts\r\n     set frozen = coalesce(p_frozen, false)\r\n   where id = p_account_id;\r\n\r\n  if not found then\r\n    raise exception 'account % not found', p_account_id;\r\n  end if;\r\nend;\r\n$$",
      "revoke all on function public.admin_set_clinic_frozen(uuid, boolean) from public",
      "grant execute on function public.admin_set_clinic_frozen(uuid, boolean) to authenticated",
      "create or replace function public.admin_delete_clinic(p_account_id uuid)\r\nreturns void\r\nlanguage plpgsql\r\nsecurity definer\r\nset search_path = public, auth\r\nas $$\r\ndeclare\r\n  v_is_super boolean := coalesce(fn_is_super_admin(), false)\r\n    or lower(coalesce(auth.jwt()->>'role', '')) = 'superadmin'\r\n    or lower(coalesce(auth.jwt()->>'email', '')) = 'admin@elmam.com';\r\nbegin\r\n  if p_account_id is null then\r\n    raise exception 'account_id is required';\r\n  end if;\r\n\r\n  if not v_is_super then\r\n    if not exists (\r\n      select 1\r\n      from public.account_users au\r\n      where au.account_id = p_account_id\r\n        and au.user_uid = auth.uid()\r\n        and coalesce(au.disabled, false) = false\r\n        and lower(coalesce(au.role, '')) in ('owner', 'admin', 'superadmin')\r\n    ) then\r\n      raise exception 'forbidden' using errcode = '42501';\r\n    end if;\r\n  end if;\r\n\r\n  delete from public.accounts\r\n  where id = p_account_id;\r\n\r\n  if not found then\r\n    raise exception 'account % not found', p_account_id;\r\n  end if;\r\nend;\r\n$$",
      "revoke all on function public.admin_delete_clinic(uuid) from public",
      "grant execute on function public.admin_delete_clinic(uuid) to authenticated",
      "notify pgrst, 'reload schema'"
    ],
    "name": "rpc_my_account_id_and_my_accounts"
  },
  {
    "version": "20250901080500",
    "statements": [
      "-- 20250901080500_profiles_bootstrap.sql\n-- Early bootstrap for public.profiles so that RPCs defined in 20250901090100 can reference the table.\n-- Full indexes/policies remain in 20250923000000_profiles_table.sql.\n\nCREATE TABLE IF NOT EXISTS public.profiles (\n  id uuid PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,\n  account_id uuid REFERENCES public.accounts(id) ON DELETE SET NULL,\n  role text NOT NULL DEFAULT 'employee',\n  display_name text,\n  created_at timestamptz NOT NULL DEFAULT now(),\n  updated_at timestamptz NOT NULL DEFAULT now()\n)",
      "CREATE INDEX IF NOT EXISTS profiles_account_idx ON public.profiles(account_id)"
    ],
    "name": "profiles_bootstrap"
  },
  {
    "version": "20250901080000",
    "statements": [
      "-- bootstrap minimal tables used by early RPC functions\nCREATE EXTENSION IF NOT EXISTS \"pgcrypto\"",
      "CREATE TABLE IF NOT EXISTS public.accounts (\n  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),\n  name text NOT NULL,\n  frozen boolean NOT NULL DEFAULT false,\n  created_at timestamptz NOT NULL DEFAULT now()\n)",
      "CREATE TABLE IF NOT EXISTS public.account_users (\n  account_id uuid NOT NULL REFERENCES public.accounts(id) ON DELETE CASCADE,\n  user_uid uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,\n  role text NOT NULL DEFAULT 'employee',\n  disabled boolean NOT NULL DEFAULT false,\n  email text,\n  created_at timestamptz NOT NULL DEFAULT now(),\n  updated_at timestamptz NOT NULL DEFAULT now(),\n  device_id text NOT NULL DEFAULT '',\n  local_id bigint,\n  PRIMARY KEY (account_id, user_uid)\n)",
      "CREATE INDEX IF NOT EXISTS account_users_account_idx ON public.account_users(account_id)",
      "CREATE INDEX IF NOT EXISTS account_users_user_idx ON public.account_users(user_uid)",
      "CREATE INDEX IF NOT EXISTS account_users_role_idx ON public.account_users(role)"
    ],
    "name": "accounts_and_account_users"
  }
]




اريد منك ان تقوم بقرائة وفهم جيدا الية عمل التطبيق والترابط في مابين الاكواد الشاشات ومهمة كل منهم وقم بالتاكد 100% ان التزامن صحيح ما بين التطبيق والسحابة دون وجود اي اخطاء وبالاخص الية العمل في ما بين الحسابات السوبر ادمن وحساب المالك وحساب الموظفين والمميزات المتاحة لكل حساب وصلاحياته