# تدقيق الحسابات والأدوار (Super Admin / Owner / Employee)

هذا الملخص يجمع تدفّق إنشاء الحسابات وتحقّق الصلاحيات في التطبيق، مع النقاط التي قد تُسبب فشل تمييز السوبر أدمن أو تعثر إنشاء حساب مالك من شاشة تسجيل الدخول.

## تدفّق التعرف على السوبر أدمن
- **مصدر القرار الأساسي** هو استعلام GraphQL `fn_is_super_admin_gql` عبر `NhostAuthService._resolveSuperAdminFlag`. أي خطأ في كشف الدالة أو صلاحياتها يؤدي لاعتبار المستخدم ليس سوبر أدمن.
- **التحديث داخل المزوّد**: `AuthProvider._refreshUser` يضبط `role` إلى `superadmin` إذا كان العلم `isSuperAdmin` مرفوعًا، ثم يخزّنه في الذاكرة والتخزين المحلي. أي فشل في جلب `isSuperAdmin` يترك المستخدم بدور `employee` حتى لو كان من المفترض أن يكون سوبر أدمن.
- **التحقق قبل عمليات الإدارة**: خدمات الإدارة تطلب `fn_is_super_admin_gql` مرة أخرى قبل أي استدعاء (مثلاً إنشاء العيادة أو الموظف)، لذلك غياب الدالة أو إرجاع `false` يمنع العمليات حتى لو كانت جلسة المستخدم تحمل دور `superadmin` ضمن الـ JWT فقط.

> **مخاطر محتملة**: إذا لم تُنشر الدالة `fn_is_super_admin_gql` أو لم تُطبّق صلاحياتها، فلن يُتعرّف على السوبر أدمن وستُحجب شاشة الإدارة وعمليات إنشاء الحسابات.

## إنشاء حساب المالك من شاشة تسجيل الدخول
- **تسجيل جديد**: عند `signUp`، يطلب التطبيق اسم العيادة ثم يستدعي `self_create_account` لتوليد حساب مالك بخطة FREE. الفشل في تفعيل الجلسة أو إرجاع `null` من الـ session يوقف الإنشاء ويعرض خطأ للمستخدم.
- **تسجيل دخول لمستخدم بلا حساب**: بعد تسجيل الدخول أو استئناف جلسة بلا `accountId`، تُنفَّذ `_ensureAutoAccount` التي تستدعي `self_create_account` تلقائيًا (مع إعادة محاولات محدودة وتفسير أخطاء المخطط/الصلاحيات). إذا لم تكن دالة `self_create_account` مكشوفة تحت `mutation_root` أو كانت صلاحياتها تمنع المستخدم الجديد، تظهر رسالة أن الخادم غير مهيأ ويُترك المستخدم بلا حساب نشط.
- **تعزيز التخزين**: `NhostAuthService.fetchCurrentUser` يحاول حفظ `accountId` في `ActiveAccountStore` عند نجاح الاستعلامات، لكن في حال فشل جميع الاستعلامات ستبقى القيمة فارغة وبالتالي يفشل الحارس `_ensureActiveAccountOrSignOut` ويُرجع حالة `noAccount` أو `networkError`.

> **مخاطر محتملة**: غياب دالة `self_create_account` أو عدم ضبطها كـ VOLATILE/مكشوفة للـ mutation يُنتج أخطاء "not found in type/mutation_root" ويمنع إنشاء حساب المالك تلقائيًا. كذلك أي فشل في حفظ `accountId` سيُبقي المستخدم في حالة "لم يتم ربط هذا المستخدم بأي عيادة".

## صلاحيات المالك والموظف
- **حراسة الحساب**: `_ensureActiveAccountOrSignOut` يخرج مبكرًا للسوبر أدمن، لكنه يفرض على المالك/الموظف جلب `activeAccount` مع التحقق من التعطيل أو التجميد وخطة الباقة. أي خطأ نهائي يرمي استثناءات `AccountFrozenException` أو `AccountUserDisabledException` أو `PlanUpgradeRequiredException` التي تُترجم إلى رسائل واجهة الاستخدام.
- **بوابة الصلاحيات**: حتى بعد تسجيل الدخول، ميزات CRUD والدردشة تُقفل افتراضيًا حتى تحميل `my_feature_permissions`. السوبر أدمن يتجاوز هذا القفل بالكامل، بينما المالك/الموظف يعتمدون على البيانات المخزَّنة أو الاستعلام الناجح؛ أي فشل يعني إخفاء الميزات (fail-closed).

## توافق أعمدة auth.users
- **Nhost يختلف عن Supabase** في أسماء أعمدة بيانات المستخدم. بعض البيئات لا تحتوي على `raw_app_meta_data` و`raw_user_meta_data`.
- لهذا السبب تم اعتماد دالة وسيطة آمنة `auth_set_user_claims` لتحديث claims/metadata فقط للأعمدة الموجودة فعليًا قبل أي إنشاء حساب أو تحديث دور.
- أي استدعاء مباشر لتلك الأعمدة القديمة سيؤدي إلى خطأ قاعدة بيانات من نوع `column does not exist` ويتسبب في فشل إنشاء الحساب بالكامل.

> **ملاحظة تشغيلية**: يجب الاعتماد على `auth_set_user_claims` داخل `self_create_account` و`admin_create_owner_full` و`admin_create_employee_full` لضمان التوافق عبر بيئات Nhost المختلفة.

## نقاط تحقق للمستخدمين
1. تأكد من نشر `fn_is_super_admin_gql` وتطبيق صلاحياتها الصحيحة لتجنب تجاهل حساب السوبر أدمن.
2. فعّل دالة `self_create_account` ضمن `mutation_root` (VOLATILE) مع صلاحيات PUBLIC كي لا يفشل إنشاء المالك من شاشة التسجيل.
3. راقب رسائل "الخادم غير مهيأ بعد" أو "لم يتم ربط هذا المستخدم بأي عيادة"؛ ظهورها يعني أن استعلامات الحساب أو الدوال المطلوبة غير متاحة من Hasura.
4. عند فشل التحقق الشبكي المتكرر، يبقي `AuthProvider` الجلسة لكنه يُرجع حالة `networkError`، ما قد يتطلب إعادة محاولة أو فحص اتصال Nhost قبل إكمال الإعداد.
5. في حال ظهور خطأ `column does not exist` داخل `auth.users`، فذلك يعني وجود تحديثات غير آمنة للـ metadata ويجب الرجوع للدالة الوسيطة بدل الأعمدة غير الموجودة.
